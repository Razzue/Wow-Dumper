<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Reloaded.Memory</name>
    </assembly>
    <members>
        <member name="T:Reloaded.Memory.Endian">
            <summary>
            Provides various utilities for converting primitives and structures between endians.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Endian.Reverse``1(``0@,``0@)">
            <summary>
            Reverses the endian of a primitive value such as int, short, float, double etc. (Not including structs).
            </summary>
            <param name="type">The individual value to be byte reversed.</param>
            <param name="swapped">The output variable to receive the swapped out value.</param>
        </member>
        <member name="M:Reloaded.Memory.Endian.Reverse``1(``0@)">
            <summary>
            Reverses the endian of a primitive value such as int, short, float, double etc. (Not including structs).
            </summary>
            <param name="type">The individual value to be byte reversed. The value will be modified directly.</param>
        </member>
        <member name="T:Reloaded.Memory.Exceptions.MemoryAllocationException">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Exceptions.MemoryAllocationException.#ctor">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Exceptions.MemoryAllocationException.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Exceptions.MemoryAllocationException.#ctor(System.String,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Exceptions.MemoryAllocationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:Reloaded.Memory.Exceptions.MemoryException">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Exceptions.MemoryException.#ctor">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Exceptions.MemoryException.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Exceptions.MemoryException.#ctor(System.String,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Exceptions.MemoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:Reloaded.Memory.Exceptions.MemoryPermissionException">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Exceptions.MemoryPermissionException.#ctor">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Exceptions.MemoryPermissionException.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Exceptions.MemoryPermissionException.#ctor(System.String,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Exceptions.MemoryPermissionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:Reloaded.Memory.IEndianReversible">
            <summary>
            An interface applicable to classes or structs exposing a method to reverse the endian of all members.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.IEndianReversible.SwapEndian">
            <summary>
            Reverses the endian-ness of this class or struct instance.
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Interop.Pinnable`1">
            <summary>
            Allows you to pin a native unmanaged object in a static location in memory, to be
            later accessible from native code.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Interop.Pinnable`1.Value">
            <summary>
            The value pointed to by the <see cref="P:Reloaded.Memory.Interop.Pinnable`1.Pointer"/>.
            If the class was instantiated using an array, this is the first element of the array.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Interop.Pinnable`1.Pointer">
            <summary>
            Pointer to the native value in question.
            If the class was instantiated using an array, this is the pointer to the first element of the array.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Interop.Pinnable`1.#ctor(`0[])">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Interop.Pinnable`1.#ctor(`0)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Interop.Pinnable`1.#ctor(`0@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Interop.Pinnable`1.Finalize">
            <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
        </member>
        <member name="M:Reloaded.Memory.Interop.Pinnable`1.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Reloaded.Memory.Interop.PinnableDisposable`1">
            <summary>
            A <see cref="T:Reloaded.Memory.Interop.Pinnable`1"/> that automatically disposes of the native object once it is either manually disposed
            or garbage collected.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Interop.PinnableDisposable`1.#ctor(`0)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Interop.PinnableDisposable`1.#ctor(`0@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Interop.PinnableDisposable`1.Finalize">
            <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
        </member>
        <member name="M:Reloaded.Memory.Interop.PinnableDisposable`1.Dispose">
            <summary/>
        </member>
        <member name="T:Reloaded.Memory.Kernel32.Kernel32">
            <summary/>
        </member>
        <member name="M:Reloaded.Memory.Kernel32.Kernel32.ReadProcessMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.UIntPtr,System.UIntPtr@)">
            <summary>Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.</summary>
            <param name="hProcess">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="lpBaseAddress">
            A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the
            base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.
            </param>
            <param name="lpBuffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="nSize">The number of bytes to be read from the specified process.</param>
            <param name="lpNumberOfBytesRead">
            A pointer to a variable that receives the number of bytes transferred into the specified buffer. If lpNumberOfBytesRead is <c>NULL</c>, the parameter
            is ignored.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is 0 (zero). To get extended error information, call <c>GetLastError</c>.</para>
            <para>The function fails if the requested read operation crosses into an area of the process that is inaccessible.</para>
            </returns>
        </member>
        <member name="M:Reloaded.Memory.Kernel32.Kernel32.WriteProcessMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.UIntPtr,System.UIntPtr@)">
            <summary>Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.</summary>
            <param name="hProcess">
            A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.
            </param>
            <param name="lpBaseAddress">
            A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in
            the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.
            </param>
            <param name="lpBuffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="nSize">The number of bytes to be written to the specified process.</param>
            <param name="lpNumberOfBytesWritten">
            A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If
            lpNumberOfBytesWritten is <c>NULL</c>, the parameter is ignored.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>
            If the function fails, the return value is 0 (zero). To get extended error information, call <c>GetLastError</c>. The function fails if the requested
            write operation crosses into an area of the process that is inaccessible.
            </para>
            </returns>
        </member>
        <member name="M:Reloaded.Memory.Kernel32.Kernel32.VirtualAllocEx(System.IntPtr,System.IntPtr,System.UIntPtr,Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE,Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION)">
            <summary>
            <para>
            Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process. The function initializes the
            memory it allocates to zero.
            </para>
            <para>To specify the NUMA node for the physical memory, see <c>VirtualAllocExNuma</c>.</para>
            </summary>
            <param name="hProcess">
            <para>The handle to a process. The function allocates memory within the virtual address space of this process.</para>
            <para>The handle must have the <c>PROCESS_VM_OPERATION</c> access right. For more information, see Process Security and Access Rights.</para>
            </param>
            <param name="lpAddress">
            <para>The pointer that specifies a desired starting address for the region of pages that you want to allocate.</para>
            <para>If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation granularity.</para>
            <para>
            If you are committing memory that is already reserved, the function rounds this address down to the nearest page boundary. To determine the size of a
            page and the allocation granularity on the host computer, use the <c>GetSystemInfo</c> function.
            </para>
            <para>If lpAddress is <c>NULL</c>, the function determines where to allocate the region.</para>
            <para>
            If this address is within an enclave that you have not initialized by calling <c>InitializeEnclave</c>, <c>VirtualAllocEx</c> allocates a page of
            zeros for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel
            Software Guard Extensions programming model.
            </para>
            <para>If the address in within an enclave that you initialized, then the allocation operation fails with the <c>ERROR_INVALID_ADDRESS</c> error.</para>
            </param>
            <param name="dwSize">
            <para>The size of the region of memory to allocate, in bytes.</para>
            <para>If lpAddress is <c>NULL</c>, the function rounds dwSize up to the next page boundary.</para>
            <para>
            If lpAddress is not <c>NULL</c>, the function allocates all pages that contain one or more bytes in the range from lpAddress to lpAddress+dwSize.
            This means, for example, that a 2-byte range that straddles a page boundary causes the function to allocate both pages.
            </para>
            </param>
            <param name="flAllocationType">
            <para>The type of memory allocation. This parameter must contain one of the following values.</para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MEM_COMMIT0x00001000</term>
            <term>
            Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also
            guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical pages are not allocated unless/until
            the virtual addresses are actually accessed.To reserve and commit pages in one step, call VirtualAllocEx with .Attempting to commit a specific
            address range by specifying MEM_COMMIT without MEM_RESERVE and a non-NULL lpAddress fails unless the entire range has already been reserved. The
            resulting error code is ERROR_INVALID_ADDRESS.An attempt to commit a page that is already committed does not cause the function to fail. This means
            that you can commit pages without first determining the current commitment state of each page.If lpAddress specifies an address within an enclave,
            flAllocationType must be MEM_COMMIT.
            </term>
            </item>
            <item>
            <term>MEM_RESERVE0x00002000</term>
            <term>
            Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on
            disk.You commit reserved pages by calling VirtualAllocEx again with MEM_COMMIT. To reserve and commit pages in one step, call VirtualAllocEx with
            .Other memory allocation functions, such as malloc and LocalAlloc, cannot use reserved memory until it has been released.
            </term>
            </item>
            <item>
            <term>MEM_RESET0x00080000</term>
            <term>
            Indicates that data in the memory range specified by lpAddress and dwSize is no longer of interest. The pages should not be read from or written to
            the paging file. However, the memory block will be used again later, so it should not be decommitted. This value cannot be used with any other
            value.Using this value does not guarantee that the range operated on with MEM_RESET will contain zeros. If you want the range to contain zeros,
            decommit the memory and then recommit it.When you use MEM_RESET, the VirtualAllocEx function ignores the value of fProtect. However, you must still
            set fProtect to a valid protection value, such as PAGE_NOACCESS.VirtualAllocEx returns an error if you use MEM_RESET and the range of memory is
            mapped to a file. A shared view is only acceptable if it is mapped to a paging file.
            </term>
            </item>
            <item>
            <term>MEM_RESET_UNDO0x1000000</term>
            <term>
            MEM_RESET_UNDO should only be called on an address range to which MEM_RESET was successfully applied earlier. It indicates that the data in the
            specified memory range specified by lpAddress and dwSize is of interest to the caller and attempts to reverse the effects of MEM_RESET. If the
            function succeeds, that means all data in the specified address range is intact. If the function fails, at least some of the data in the address
            range has been replaced with zeroes.This value cannot be used with any other value. If MEM_RESET_UNDO is called on an address range which was not
            MEM_RESET earlier, the behavior is undefined. When you specify MEM_RESET, the VirtualAllocEx function ignores the value of flProtect. However, you
            must still set flProtect to a valid protection value, such as PAGE_NOACCESS.Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista,
            Windows Server 2003 and Windows XP: The MEM_RESET_UNDO flag is not supported until Windows 8 and Windows Server 2012.
            </term>
            </item>
            </list>
            </para>
            <para>This parameter can also specify the following values as indicated.</para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MEM_LARGE_PAGES0x20000000</term>
            <term>
            Allocates memory using large page support.The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the
            GetLargePageMinimum function.If you specify this value, you must also specify MEM_RESERVE and MEM_COMMIT.
            </term>
            </item>
            <item>
            <term>MEM_PHYSICAL0x00400000</term>
            <term>
            Reserves an address range that can be used to map Address Windowing Extensions (AWE) pages.This value must be used with MEM_RESERVE and no other values.
            </term>
            </item>
            <item>
            <term>MEM_TOP_DOWN0x00100000</term>
            <term>Allocates memory at the highest possible address. This can be slower than regular allocations, especially when there are many allocations.</term>
            </item>
            </list>
            </para>
            </param>
            <param name="flProtect">
            <para>
            The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the memory protection constants.
            </para>
            <para>If lpAddress specifies an address within an enclave, flProtect cannot be any of the following values:</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call <c>GetLastError</c>.</para>
            </returns>
        </member>
        <member name="M:Reloaded.Memory.Kernel32.Kernel32.VirtualFreeEx(System.IntPtr,System.IntPtr,System.UIntPtr,Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE)">
            <summary>Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified process.</summary>
            <param name="hProcess">
            <para>A handle to a process. The function frees memory within the virtual address space of the process.</para>
            <para>The handle must have the <c>PROCESS_VM_OPERATION</c> access right. For more information, see Process Security and Access Rights.</para>
            </param>
            <param name="lpAddress">
            <para>A pointer to the starting address of the region of memory to be freed.</para>
            <para>
            If the dwFreeType parameter is <c>MEM_RELEASE</c>, lpAddress must be the base address returned by the <c>VirtualAllocEx</c> function when the region
            is reserved.
            </para>
            </param>
            <param name="dwSize">
            <para>The size of the region of memory to free, in bytes.</para>
            <para>
            If the dwFreeType parameter is <c>MEM_RELEASE</c>, dwSize must be 0 (zero). The function frees the entire region that is reserved in the initial
            allocation call to <c>VirtualAllocEx</c>.
            </para>
            <para>
            If dwFreeType is <c>MEM_DECOMMIT</c>, the function decommits all memory pages that contain one or more bytes in the range from the lpAddress
            parameter to . This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be decommitted. If
            lpAddress is the base address returned by <c>VirtualAllocEx</c> and dwSize is 0 (zero), the function decommits the entire region that is allocated by
            <c>VirtualAllocEx</c>. After that, the entire region is in the reserved state.
            </para>
            </param>
            <param name="dwFreeType">
            <para>The type of free operation. This parameter can be one of the following values.</para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MEM_DECOMMIT0x4000</term>
            <term>
            Decommits the specified region of committed pages. After the operation, the pages are in the reserved state. The function does not fail if you
            attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first determining their current commitment
            state.Do not use this value with MEM_RELEASE.The MEM_DECOMMIT value is not supported when the lpAddress parameter provides the base address for an enclave.
            </term>
            </item>
            <item>
            <term>MEM_RELEASE0x8000</term>
            <term>
            Releases the specified region of pages. After the operation, the pages are in the free state. If you specify this value, dwSize must be 0 (zero), and
            lpAddress must point to the base address returned by the VirtualAllocEx function when the region is reserved. The function fails if either of these
            conditions is not met.If any pages in the region are committed currently, the function first decommits, and then releases them.The function does not
            fail if you attempt to release pages that are in different states, some reserved and some committed. This means that you can release a range of pages
            without first determining the current commitment state.Do not use this value with MEM_DECOMMIT.
            </term>
            </item>
            </list>
            </para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a nonzero value.</para>
            <para>If the function fails, the return value is 0 (zero). To get extended error information, call <c>GetLastError</c>.</para>
            </returns>
        </member>
        <member name="M:Reloaded.Memory.Kernel32.Kernel32.VirtualProtectEx(System.IntPtr,System.IntPtr,System.UIntPtr,Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION,Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION@)">
            <summary>Changes the protection on a region of committed pages in the virtual address space of a specified process.</summary>
            <param name="hProcess">
            A handle to the process whose memory protection is to be changed. The handle must have the <c>PROCESS_VM_OPERATION</c> access right. For more
            information, see Process Security and Access Rights.
            </param>
            <param name="lpAddress">
            <para>A pointer to the base address of the region of pages whose access protection attributes are to be changed.</para>
            <para>
            All pages in the specified region must be within the same reserved region allocated when calling the <c>VirtualAlloc</c> or <c>VirtualAllocEx</c>
            function using <c>MEM_RESERVE</c>. The pages cannot span adjacent reserved regions that were allocated by separate calls to <c>VirtualAlloc</c> or
            <c>VirtualAllocEx</c> using <c>MEM_RESERVE</c>.
            </para>
            </param>
            <param name="dwSize">
            The size of the region whose access protection attributes are changed, in bytes. The region of affected pages includes all pages containing one or
            more bytes in the range from the lpAddress parameter to . This means that a 2-byte range straddling a page boundary causes the protection attributes
            of both pages to be changed.
            </param>
            <param name="flNewProtect">
            <para>The memory protection option. This parameter can be one of the memory protection constants.</para>
            <para>
            For mapped views, this value must be compatible with the access protection specified when the view was mapped (see <c>MapViewOfFile</c>,
            <c>MapViewOfFileEx</c>, and <c>MapViewOfFileExNuma</c>).
            </para>
            </param>
            <param name="lpflOldProtect">
            A pointer to a variable that receives the previous access protection of the first page in the specified region of pages. If this parameter is
            <c>NULL</c> or does not point to a valid variable, the function fails.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call <c>GetLastError</c>.</para>
            </returns>
        </member>
        <member name="M:Reloaded.Memory.Kernel32.Kernel32.VirtualAlloc(System.IntPtr,System.UIntPtr,Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE,Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION)">
            <summary>
            <para>
            Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process. Memory allocated by this function
            is automatically initialized to zero.
            </para>
            <para>To allocate memory in the address space of another process, use the <c>VirtualAllocEx</c> function.</para>
            </summary>
            <param name="lpAddress">
            <para>
            The starting address of the region to allocate. If the memory is being reserved, the specified address is rounded down to the nearest multiple of the
            allocation granularity. If the memory is already reserved and is being committed, the address is rounded down to the next page boundary. To determine
            the size of a page and the allocation granularity on the host computer, use the <c>GetSystemInfo</c> function. If this parameter is <c>NULL</c>, the
            system determines where to allocate the region.
            </para>
            <para>
            If this address is within an enclave that you have not initialized by calling <c>InitializeEnclave</c>, <c>VirtualAlloc</c> allocates a page of zeros
            for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software
            Guard Extensions programming model.
            </para>
            <para>If the address in within an enclave that you initialized, then the allocation operation fails with the <c>ERROR_INVALID_ADDRESS</c> error.</para>
            </param>
            <param name="dwSize">
            The size of the region, in bytes. If the lpAddress parameter is <c>NULL</c>, this value is rounded up to the next page boundary. Otherwise, the
            allocated pages include all pages containing one or more bytes in the range from lpAddress to lpAddress+dwSize. This means that a 2-byte range
            straddling a page boundary causes both pages to be included in the allocated region.
            </param>
            <param name="flAllocationType">
            <para>The type of memory allocation. This parameter must contain one of the following values.</para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MEM_COMMIT0x00001000</term>
            <term>
            Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also
            guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical pages are not allocated unless/until
            the virtual addresses are actually accessed.To reserve and commit pages in one step, call VirtualAlloc with .Attempting to commit a specific address
            range by specifying MEM_COMMIT without MEM_RESERVE and a non-NULL lpAddress fails unless the entire range has already been reserved. The resulting
            error code is ERROR_INVALID_ADDRESS.An attempt to commit a page that is already committed does not cause the function to fail. This means that you
            can commit pages without first determining the current commitment state of each page.If lpAddress specifies an address within an enclave,
            flAllocationType must be MEM_COMMIT.
            </term>
            </item>
            <item>
            <term>MEM_RESERVE0x00002000</term>
            <term>
            Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on
            disk.You can commit reserved pages in subsequent calls to the VirtualAlloc function. To reserve and commit pages in one step, call VirtualAlloc with
            MEM_COMMIT | MEM_RESERVE.Other memory allocation functions, such as malloc and LocalAlloc, cannot use a reserved range of memory until it is released.
            </term>
            </item>
            <item>
            <term>MEM_RESET0x00080000</term>
            <term>
            Indicates that data in the memory range specified by lpAddress and dwSize is no longer of interest. The pages should not be read from or written to
            the paging file. However, the memory block will be used again later, so it should not be decommitted. This value cannot be used with any other
            value.Using this value does not guarantee that the range operated on with MEM_RESET will contain zeros. If you want the range to contain zeros,
            decommit the memory and then recommit it.When you specify MEM_RESET, the VirtualAlloc function ignores the value of flProtect. However, you must
            still set flProtect to a valid protection value, such as PAGE_NOACCESS.VirtualAlloc returns an error if you use MEM_RESET and the range of memory is
            mapped to a file. A shared view is only acceptable if it is mapped to a paging file.
            </term>
            </item>
            <item>
            <term>MEM_RESET_UNDO0x1000000</term>
            <term>
            MEM_RESET_UNDO should only be called on an address range to which MEM_RESET was successfully applied earlier. It indicates that the data in the
            specified memory range specified by lpAddress and dwSize is of interest to the caller and attempts to reverse the effects of MEM_RESET. If the
            function succeeds, that means all data in the specified address range is intact. If the function fails, at least some of the data in the address
            range has been replaced with zeroes.This value cannot be used with any other value. If MEM_RESET_UNDO is called on an address range which was not
            MEM_RESET earlier, the behavior is undefined. When you specify MEM_RESET, the VirtualAlloc function ignores the value of flProtect. However, you must
            still set flProtect to a valid protection value, such as PAGE_NOACCESS.Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows
            Server 2003 and Windows XP: The MEM_RESET_UNDO flag is not supported until Windows 8 and Windows Server 2012.
            </term>
            </item>
            </list>
            </para>
            <para>This parameter can also specify the following values as indicated.</para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MEM_LARGE_PAGES0x20000000</term>
            <term>
            Allocates memory using large page support.The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the
            GetLargePageMinimum function.If you specify this value, you must also specify MEM_RESERVE and MEM_COMMIT.
            </term>
            </item>
            <item>
            <term>MEM_PHYSICAL0x00400000</term>
            <term>
            Reserves an address range that can be used to map Address Windowing Extensions (AWE) pages.This value must be used with MEM_RESERVE and no other values.
            </term>
            </item>
            <item>
            <term>MEM_TOP_DOWN0x00100000</term>
            <term>Allocates memory at the highest possible address. This can be slower than regular allocations, especially when there are many allocations.</term>
            </item>
            <item>
            <term>MEM_WRITE_WATCH0x00200000</term>
            <term>
            Causes the system to track pages that are written to in the allocated region. If you specify this value, you must also specify MEM_RESERVE.To
            retrieve the addresses of the pages that have been written to since the region was allocated or the write-tracking state was reset, call the
            GetWriteWatch function. To reset the write-tracking state, call GetWriteWatch or ResetWriteWatch. The write-tracking feature remains enabled for the
            memory region until the region is freed.
            </term>
            </item>
            </list>
            </para>
            </param>
            <param name="flProtect">
            <para>
            The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the memory protection constants.
            </para>
            <para>If lpAddress specifies an address within an enclave, flProtect cannot be any of the following values:</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call <c>GetLastError</c>.</para>
            </returns>
        </member>
        <member name="M:Reloaded.Memory.Kernel32.Kernel32.VirtualFree(System.IntPtr,System.UIntPtr,Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE)">
            <summary>
            <para>Releases, decommits, or releases and decommits a region of pages within the virtual address space of the calling process.</para>
            <para>To free memory allocated in another process by the <c>VirtualAllocEx</c> function, use the <c>VirtualFreeEx</c> function.</para>
            </summary>
            <param name="lpAddress">
            <para>A pointer to the base address of the region of pages to be freed.</para>
            <para>
            If the dwFreeType parameter is <c>MEM_RELEASE</c>, this parameter must be the base address returned by the <c>VirtualAlloc</c> function when the
            region of pages is reserved.
            </para>
            </param>
            <param name="dwSize">
            <para>The size of the region of memory to be freed, in bytes.</para>
            <para>
            If the dwFreeType parameter is <c>MEM_RELEASE</c>, this parameter must be 0 (zero). The function frees the entire region that is reserved in the
            initial allocation call to <c>VirtualAlloc</c>.
            </para>
            <para>
            If the dwFreeType parameter is <c>MEM_DECOMMIT</c>, the function decommits all memory pages that contain one or more bytes in the range from the
            lpAddress parameter to . This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be decommitted.
            If lpAddress is the base address returned by <c>VirtualAlloc</c> and dwSize is 0 (zero), the function decommits the entire region that is allocated
            by <c>VirtualAlloc</c>. After that, the entire region is in the reserved state.
            </para>
            </param>
            <param name="dwFreeType">
            <para>The type of free operation. This parameter can be one of the following values.</para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MEM_DECOMMIT0x4000</term>
            <term>
            Decommits the specified region of committed pages. After the operation, the pages are in the reserved state. The function does not fail if you
            attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first determining the current commitment state.Do
            not use this value with MEM_RELEASE.The MEM_DECOMMIT value is not supported when the lpAddress parameter provides the base address for an enclave.
            </term>
            </item>
            <item>
            <term>MEM_RELEASE0x8000</term>
            <term>
            Releases the specified region of pages. After this operation, the pages are in the free state. If you specify this value, dwSize must be 0 (zero),
            and lpAddress must point to the base address returned by the VirtualAlloc function when the region is reserved. The function fails if either of these
            conditions is not met.If any pages in the region are committed currently, the function first decommits, and then releases them.The function does not
            fail if you attempt to release pages that are in different states, some reserved and some committed. This means that you can release a range of pages
            without first determining the current commitment state.Do not use this value with MEM_DECOMMIT.
            </term>
            </item>
            </list>
            </para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is 0 (zero). To get extended error information, call <c>GetLastError</c>.</para>
            </returns>
        </member>
        <member name="M:Reloaded.Memory.Kernel32.Kernel32.VirtualProtect(System.IntPtr,System.UIntPtr,Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION,Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION@)">
            <summary>
            <para>Changes the protection on a region of committed pages in the virtual address space of the calling process.</para>
            <para>To change the access protection of any process, use the <c>VirtualProtectEx</c> function.</para>
            </summary>
            <param name="lpAddress">
            <para>A pointer an address that describes the starting page of the region of pages whose access protection attributes are to be changed.</para>
            <para>
            All pages in the specified region must be within the same reserved region allocated when calling the <c>VirtualAlloc</c> or <c>VirtualAllocEx</c>
            function using <c>MEM_RESERVE</c>. The pages cannot span adjacent reserved regions that were allocated by separate calls to <c>VirtualAlloc</c> or
            <c>VirtualAllocEx</c> using <c>MEM_RESERVE</c>.
            </para>
            </param>
            <param name="dwSize">
            The size of the region whose access protection attributes are to be changed, in bytes. The region of affected pages includes all pages containing one
            or more bytes in the range from the lpAddress parameter to . This means that a 2-byte range straddling a page boundary causes the protection
            attributes of both pages to be changed.
            </param>
            <param name="flNewProtect">
            <para>The memory protection option. This parameter can be one of the memory protection constants.</para>
            <para>
            For mapped views, this value must be compatible with the access protection specified when the view was mapped (see <c>MapViewOfFile</c>,
            <c>MapViewOfFileEx</c>, and <c>MapViewOfFileExNuma</c>).
            </para>
            </param>
            <param name="lpflOldProtect">
            A pointer to a variable that receives the previous access protection value of the first page in the specified region of pages. If this parameter is
            <c>NULL</c> or does not point to a valid variable, the function fails.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call <c>GetLastError</c>.</para>
            </returns>
        </member>
        <member name="T:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE">
            <summary>The type of memory allocation.</summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_COMMIT">
            <summary>
            Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages. The function
            also guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical pages are not allocated
            unless/until the virtual addresses are actually accessed.To reserve and commit pages in one step, call VirtualAlloc with .Attempting to commit a
            specific address range by specifying MEM_COMMIT without MEM_RESERVE and a non-NULL lpAddress fails unless the entire range has already been
            reserved. The resulting error code is ERROR_INVALID_ADDRESS.An attempt to commit a page that is already committed does not cause the function to
            fail. This means that you can commit pages without first determining the current commitment state of each page.If lpAddress specifies an address
            within an enclave, flAllocationType must be MEM_COMMIT.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_RESERVE">
            <summary>
            Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on
            disk.You can commit reserved pages in subsequent calls to the VirtualAlloc function. To reserve and commit pages in one step, call VirtualAlloc
            with MEM_COMMIT | MEM_RESERVE.Other memory allocation functions, such as malloc and LocalAlloc, cannot use a reserved range of memory until it is released.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_DECOMMIT">
            <summary>
            Decommits the specified region of committed pages. After the operation, the pages are in the reserved state. The function does not fail if you
            attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first determining the current commitment
            state.Do not use this value with MEM_RELEASE.The MEM_DECOMMIT value is not supported when the lpAddress parameter provides the base address for
            an enclave.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_RELEASE">
            <summary>
            Releases the specified region of pages. After this operation, the pages are in the free state. If you specify this value, dwSize must be 0
            (zero), and lpAddress must point to the base address returned by the VirtualAlloc function when the region is reserved. The function fails if
            either of these conditions is not met. If any pages in the region are committed currently, the function first decommits, and then releases
            them.The function does not fail if you attempt to release pages that are in different states, some reserved and some committed. This means that
            you can release a range of pages without first determining the current commitment state.Do not use this value with MEM_DECOMMIT.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_FREE">
            <summary>
            Indicates free pages not accessible to the calling process and available to be allocated. For free pages, the information in the AllocationBase,
            AllocationProtect, Protect, and Type members is undefined.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_PRIVATE">
            <summary>Indicates that the memory pages within the region are private (that is, not shared by other processes).</summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_MAPPED">
            <summary>Indicates that the memory pages within the region are mapped into the view of a section.</summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_RESET">
            <summary>
            Indicates that data in the memory range specified by lpAddress and dwSize is no longer of interest. The pages should not be read from or written
            to the paging file. However, the memory block will be used again later, so it should not be decommitted. This value cannot be used with any other
            value.Using this value does not guarantee that the range operated on with MEM_RESET will contain zeros. If you want the range to contain zeros,
            decommit the memory and then recommit it.When you specify MEM_RESET, the VirtualAlloc function ignores the value of flProtect. However, you must
            still set flProtect to a valid protection value, such as PAGE_NOACCESS.VirtualAlloc returns an error if you use MEM_RESET and the range of memory
            is mapped to a file. A shared view is only acceptable if it is mapped to a paging file.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_TOP_DOWN">
            <summary>Allocates memory at the highest possible address. This can be slower than regular allocations, especially when there are many allocations.</summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_WRITE_WATCH">
            <summary>
            Causes the system to track pages that are written to in the allocated region. If you specify this value, you must also specify MEM_RESERVE.To
            retrieve the addresses of the pages that have been written to since the region was allocated or the write-tracking state was reset, call the
            GetWriteWatch function. To reset the write-tracking state, call GetWriteWatch or ResetWriteWatch. The write-tracking feature remains enabled for
            the memory region until the region is freed.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_PHYSICAL">
            <summary>
            Reserves an address range that can be used to map Address Windowing Extensions (AWE) pages.This value must be used with MEM_RESERVE and no other values.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_ROTATE">
            <summary></summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_DIFFERENT_IMAGE_BASE_OK">
            <summary></summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_RESET_UNDO">
            <summary>
            MEM_RESET_UNDO should only be called on an address range to which MEM_RESET was successfully applied earlier. It indicates that the data in the
            specified memory range specified by lpAddress and dwSize is of interest to the caller and attempts to reverse the effects of MEM_RESET. If the
            function succeeds, that means all data in the specified address range is intact. If the function fails, at least some of the data in the address
            range has been replaced with zeroes.This value cannot be used with any other value. If MEM_RESET_UNDO is called on an address range which was not
            MEM_RESET earlier, the behavior is undefined. When you specify MEM_RESET, the VirtualAlloc function ignores the value of flProtect. However, you
            must still set flProtect to a valid protection value, such as PAGE_NOACCESS.Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows
            Vista, Windows Server 2003 and Windows XP: The MEM_RESET_UNDO flag is not supported until Windows 8 and Windows Server 2012.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_LARGE_PAGES">
            <summary>
            Allocates memory using large page support.The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the
            GetLargePageMinimum function.If you specify this value, you must also specify MEM_RESERVE and MEM_COMMIT.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_4MB_PAGES">
            <summary></summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_64K_PAGES">
            <summary></summary>
        </member>
        <member name="T:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION">
            <summary>
            The following are the memory-protection options; you must specify one of the following values when allocating or protecting a page in memory.
            Protection attributes cannot be assigned to a portion of a page; they can only be assigned to a whole page.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_NOACCESS">
            <summary>
            Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an access violation.
            <para>This flag is not supported by the CreateFileMapping function.</para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_READONLY">
            <summary>
            Enables read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation. If Data
            Execution Prevention is enabled, an attempt to execute code in the committed region results in an access violation.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_READWRITE">
            <summary>
            Enables read-only or read/write access to the committed region of pages. If Data Execution Prevention is enabled, attempting to execute code in
            the committed region results in an access violation.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_WRITECOPY">
            <summary>
            Enables read-only or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write page
            results in a private copy of the page being made for the process. The private page is marked as PAGE_READWRITE, and the change is written to the
            new page. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access violation.
            <para>This flag is not supported by the VirtualAlloc or VirtualAllocEx functions.</para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_EXECUTE">
            <summary>
            Enables execute access to the committed region of pages. An attempt to write to the committed region results in an access violation.
            <para>This flag is not supported by the CreateFileMapping function.</para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_EXECUTE_READ">
            <summary>
            Enables execute or read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation.
            <para>
            Windows Server 2003 and Windows XP: This attribute is not supported by the CreateFileMapping function until Windows XP with SP2 and Windows
            Server 2003 with SP1.
            </para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_EXECUTE_READWRITE">
            <summary>
            Enables execute, read-only, or read/write access to the committed region of pages.
            <para>
            Windows Server 2003 and Windows XP: This attribute is not supported by the CreateFileMapping function until Windows XP with SP2 and Windows
            Server 2003 with SP1.
            </para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_EXECUTE_WRITECOPY">
            <summary>
            Enables execute, read-only, or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write
            page results in a private copy of the page being made for the process. The private page is marked as PAGE_EXECUTE_READWRITE, and the change is
            written to the new page.
            <para>This flag is not supported by the VirtualAlloc or VirtualAllocEx functions.</para>
            <para>
            Windows Vista, Windows Server 2003 and Windows XP: This attribute is not supported by the CreateFileMapping function until Windows Vista with SP1
            and Windows Server 2008.
            </para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_GUARD">
            <summary>
            Pages in the region become guard pages. Any attempt to access a guard page causes the system to raise a STATUS_GUARD_PAGE_VIOLATION exception and
            turn off the guard page status. Guard pages thus act as a one-time access alarm. For more information, see Creating Guard Pages.
            <para>When an access attempt leads the system to turn off guard page status, the underlying page protection takes over.</para>
            <para>If a guard page exception occurs during a system service, the service typically returns a failure status indicator.</para>
            <para>This value cannot be used with PAGE_NOACCESS.</para>
            <para>This flag is not supported by the CreateFileMapping function.</para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_NOCACHE">
            <summary>
            Sets all pages to be non-cachable. Applications should not use this attribute except when explicitly required for a device. Using the interlocked
            functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.
            <para>The PAGE_NOCACHE flag cannot be used with the PAGE_GUARD, PAGE_NOACCESS, or PAGE_WRITECOMBINE flags.</para>
            <para>
            The PAGE_NOCACHE flag can be used only when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To
            enable non-cached memory access for shared memory, specify the SEC_NOCACHE flag when calling the CreateFileMapping function.
            </para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_WRITECOMBINE">
            <summary>
            Sets all pages to be write-combined.
            <para>
            Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is
            mapped as write-combined can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.
            </para>
            <para>The PAGE_WRITECOMBINE flag cannot be specified with the PAGE_NOACCESS, PAGE_GUARD, and PAGE_NOCACHE flags.</para>
            <para>
            The PAGE_WRITECOMBINE flag can be used only when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma
            functions. To enable write-combined memory access for shared memory, specify the SEC_WRITECOMBINE flag when calling the CreateFileMapping function.
            </para>
            <para>Windows Server 2003 and Windows XP: This flag is not supported until Windows Server 2003 with SP1.</para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_ENCLAVE_UNVALIDATED">
            <summary>The page contents that you supply are excluded from measurement with the EEXTEND instruction of the Intel SGX programming model.</summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_TARGETS_INVALID">
            <summary>
            Sets all locations in the pages as invalid targets for CFG. Used along with any execute page protection like PAGE_EXECUTE, PAGE_EXECUTE_READ,
            PAGE_EXECUTE_READWRITE and PAGE_EXECUTE_WRITECOPY. Any indirect call to locations in those pages will fail CFG checks and the process will be
            terminated. The default behavior for executable pages allocated is to be marked valid call targets for CFG.
            <para>This flag is not supported by the VirtualProtect or CreateFileMapping functions.</para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_TARGETS_NO_UPDATE">
            <summary>
            Pages in the region will not have their CFG information updated while the protection changes for VirtualProtect. For example, if the pages in the
            region was allocated using PAGE_TARGETS_INVALID, then the invalid information will be maintained while the page protection changes. This flag is
            only valid when the protection changes to an executable type like PAGE_EXECUTE, PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE and
            PAGE_EXECUTE_WRITECOPY. The default behavior for VirtualProtect protection change to executable is to mark all locations as valid call targets
            for CFG.
            <para>The following are modifiers that can be used in addition to the options provided in the previous table, except as noted.</para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_ENCLAVE_THREAD_CONTROL">
            <summary>The page contains a thread control structure (TCS).</summary>
        </member>
        <member name="F:Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION.PAGE_REVERT_TO_FILE_MAP">
            <summary></summary>
        </member>
        <member name="T:Reloaded.Memory.Pointers.ArrayPtr`1">
            <summary>
            Abstracts a native 'C' type array of unknown size in memory to a more familiar interface.
            TStruct can be a primitive, a struct or a class with explicit StructLayout attribute.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.ArrayPtr`1.Pointer">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Memory.Pointers.ArrayPtr`1.MarshalElements">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Memory.Pointers.ArrayPtr`1.Source">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Memory.Pointers.ArrayPtr`1.ElementSize">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Memory.Pointers.ArrayPtr`1.Item(System.Int32)">
            <summary/>
        </member>
        <member name="M:Reloaded.Memory.Pointers.ArrayPtr`1.Get(`0@,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Pointers.ArrayPtr`1.Set(`0@,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Pointers.ArrayPtr`1.#ctor(System.UInt64,System.Boolean,Reloaded.Memory.Sources.IMemory)">
            <summary>
            Constructs a new instance of <see cref="T:Reloaded.Memory.Pointers.ArrayPtr`1"/> given the address of the first element
            and whether elements should be marshaled or not as they are read.
            </summary>
            <param name="address">The address of the first element of the structure array.</param>
            <param name="marshalElements">Set to true in order to marshal elements as they are read in and out.</param>
            <param name="source">Specifies the source from which the individual array elements should be read/written.</param>
            <remarks>See <see cref="T:Reloaded.Memory.Pointers.ArrayPtr`1"/></remarks>
        </member>
        <member name="M:Reloaded.Memory.Pointers.ArrayPtr`1.GetPointerToElement(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Reloaded.Memory.Pointers.BlittablePointer`1">
            <summary>
            Blittable single level pointer type that you can use with generic types such as <see cref="T:Reloaded.Memory.Pointers.RefFixedArrayPtr`1"/> (to create array of pointers to structs).
            Requires .NET Core 3/Standard 2.1 to make good use of.
            Relevant issue: https://github.com/dotnet/csharplang/issues/1744 
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.BlittablePointer`1.Pointer">
            <summary>
            The pointer to the value.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.BlittablePointer`1.#ctor(`0*)">
            <summary>
            Creates a blittable pointer
            </summary>
            <param name="pointer"></param>
        </member>
        <member name="M:Reloaded.Memory.Pointers.BlittablePointer`1.AsRefPointer">
            <summary>
            Converts this <see cref="T:Reloaded.Memory.Pointers.BlittablePointer`1"/> to a single level <see cref="T:Reloaded.Memory.Pointers.RefPointer`1"/>.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.BlittablePointer`1.AsReference">
            <summary>
            Converts this <see cref="T:Reloaded.Memory.Pointers.BlittablePointer`1"/> to a value reference.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.BlittablePointer`1.op_Implicit(`0*)~Reloaded.Memory.Pointers.BlittablePointer{`0}">
            <summary/>
        </member>
        <member name="M:Reloaded.Memory.Pointers.BlittablePointer`1.op_Implicit(Reloaded.Memory.Pointers.BlittablePointer{`0})~`0*">
            <summary/>
        </member>
        <member name="T:Reloaded.Memory.Pointers.FixedArrayPtr`1">
            <summary>
            Abstracts a native 'C' type array of a set size in memory to a more familiar interface.
            TStruct can be a primitive, a struct or a class with explicit StructLayout attribute.
            Note: This class is not safe/does not perform range checks.
            It exists to provide additional functionality like LINQ which otherwise cannot be achieved without knowing amount of elements.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.FixedArrayPtr`1.Pointer">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Memory.Pointers.FixedArrayPtr`1.MarshalElements">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Memory.Pointers.FixedArrayPtr`1.Source">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Memory.Pointers.FixedArrayPtr`1.ElementSize">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Memory.Pointers.FixedArrayPtr`1.Count">
            <summary>
            The number of elements contained in the <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/>.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.FixedArrayPtr`1.ArraySize">
            <summary>
            Contains the size of the entire array, in bytes.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.FixedArrayPtr`1.Item(System.Int32)">
            <summary/>
        </member>
        <member name="M:Reloaded.Memory.Pointers.FixedArrayPtr`1.Get(`0@,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Pointers.FixedArrayPtr`1.Set(`0@,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Pointers.FixedArrayPtr`1.#ctor(System.UInt64,System.Int32,System.Boolean,Reloaded.Memory.Sources.IMemory)">
            <summary>
            Constructs a new instance of <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/> given the address of the first element, 
            and the number of elements that follow it.
            </summary>
            <param name="address">The address of the first element of the structure array.</param>
            <param name="count">The amount of elements in the array structure in memory.</param>
            <param name="marshalElements">If this is set to true elements will be marshaled as they are read in and out from memory.</param>
            <param name="source">Specifies the source from which the individual array elements should be read/written. This defaults to current process/local memory.</param>
        </member>
        <member name="M:Reloaded.Memory.Pointers.FixedArrayPtr`1.Contains(`0)">
            <summary>
            Determines whether an element is in the <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/>.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Reloaded.Memory.Pointers.FixedArrayPtr`1.Contains(`0@)">
            <summary>
            Determines whether an element is in the <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/>.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Reloaded.Memory.Pointers.FixedArrayPtr`1.IndexOf(`0)">
            <summary>
            Searches for a specified item and returns the index of the item
            if present.
            </summary>
            <param name="item">The item to search for in the array.</param>
            <returns>The index of the item, if present in the array.</returns>
        </member>
        <member name="M:Reloaded.Memory.Pointers.FixedArrayPtr`1.IndexOf(`0@)">
            <summary>
            Searches for a specified item and returns the index of the item
            if present.
            </summary>
            <param name="item">The item to search for in the array.</param>
            <returns>The index of the item, if present in the array.</returns>
        </member>
        <member name="M:Reloaded.Memory.Pointers.FixedArrayPtr`1.CopyFrom(`0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies all the elements of the passed in sourceArray to the <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/> array.
            </summary>
            <param name="sourceArray">The array from which to copy elements from.</param>
            <param name="length">The amount of elements in the source array that should be copied.</param>
            <param name="sourceIndex">The array index in the source array copy elements from.</param>
            <param name="destinationIndex">The starting index into the <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/> to which elements should be copied to.</param>
        </member>
        <member name="M:Reloaded.Memory.Pointers.FixedArrayPtr`1.CopyTo(`0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies all the elements from the the <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/> to the passed in sourceArray.
            </summary>
            <param name="destinationArray">The array from which to copy elements to.</param>
            <param name="length">The amount of elements in to copy to sourceArray.</param>
            <param name="sourceIndex">The array index in the <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/> to copy elements from.</param>
            <param name="destinationIndex">The starting index into the <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/> array to which elements should be copied to.</param>
        </member>
        <member name="M:Reloaded.Memory.Pointers.FixedArrayPtr`1.GetPointerToElement(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Pointers.FixedArrayPtr`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Reloaded.Memory.Pointers.FixedArrayPtr`1.FixedArrayPtrEnumerator">
            <summary>
            Implements the IEnumerator Structure for the Fixed Array Pointer, allowing for
            LINQ queries to be used.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.FixedArrayPtr`1.FixedArrayPtrEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>The element in the collection at the current position of the enumerator.</returns>
        </member>
        <member name="F:Reloaded.Memory.Pointers.FixedArrayPtr`1.FixedArrayPtrEnumerator._arrayPtr">
            <summary>
            Contains a copy of the parent object that is to be enumerated.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Pointers.FixedArrayPtr`1.FixedArrayPtrEnumerator._currentIndex">
            <summary>
            Contains the index of the current element being enumerated.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.FixedArrayPtr`1.FixedArrayPtrEnumerator.#ctor(Reloaded.Memory.Pointers.FixedArrayPtr{`0})">
            <summary>
            Constructor for the custom enumerator.
            </summary>
            <param name="parentArrayPtr">Contains original FixedArrayPtr this enumerator was intended for.</param>
        </member>
        <member name="P:Reloaded.Memory.Pointers.FixedArrayPtr`1.FixedArrayPtrEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>The element in the collection at the current position of the enumerator.</returns>
        </member>
        <member name="M:Reloaded.Memory.Pointers.FixedArrayPtr`1.FixedArrayPtrEnumerator.MoveNext">
            <summary>
            Advances the enumerator cursor to the next element of the collection.
            </summary>
            <returns>
                True if the enumerator was successfully advanced to the next element.
                False if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:Reloaded.Memory.Pointers.FixedArrayPtr`1.FixedArrayPtrEnumerator.Reset">
            <summary>
            Resets the current index and pointer to the defaults.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.FixedArrayPtr`1.FixedArrayPtrEnumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Reloaded.Memory.Pointers.IArrayPtr`1">
            <summary>
            An interface type which describes a pointer to an array in arbitrary memory.
            </summary>
            <typeparam name="TStruct">A primitive or struct type to which the pointer is intended to point to.</typeparam>
        </member>
        <member name="P:Reloaded.Memory.Pointers.IArrayPtr`1.ElementSize">
            <summary>
            Size of a single element in the array, in bytes.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.IArrayPtr`1.MarshalElements">
            <summary>
            If this is true; elements will be marshaled as they are read in and out from memory.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.IArrayPtr`1.Pointer">
            <summary>
            Gets the pointer to the start of the data contained in the <see cref="T:Reloaded.Memory.Pointers.IArrayPtr`1"/>.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.IArrayPtr`1.Source">
            <summary>
            The source where memory will be read/written to/from.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.IArrayPtr`1.GetPointerToElement(System.Int32)">
            <summary>
            Gets the pointer to the element at the given index.
            </summary>
            <param name="index">The index to retrieve a pointer for.</param>
            <returns>Pointer to the requested element at index.</returns>
        </member>
        <member name="M:Reloaded.Memory.Pointers.IArrayPtr`1.Get(`0@,System.Int32)">
            <summary>
            Gets the value of an item at a specific index.
            </summary>
            <param name="value">The value to be received from the array.</param>
            <param name="index">The index in the array from which to receive the value.</param>
        </member>
        <member name="M:Reloaded.Memory.Pointers.IArrayPtr`1.Set(`0@,System.Int32)">
            <summary>
            Sets the value of an item at a specific index.
            </summary>
            <param name="value">The value to be written.</param>
            <param name="index">The index in the array to which the value is to be written to.</param>
        </member>
        <member name="P:Reloaded.Memory.Pointers.IArrayPtr`1.Item(System.Int32)">
            <summary/>
        </member>
        <member name="T:Reloaded.Memory.Pointers.Pointer`1">
            <summary>
            Represents a reference to a value of type <typeparamref name="TStruct"/>.
            Wraps a native pointer around a managed type, improving the ease of use.
            TStruct can be a primitive, a struct or a class with explicit StructLayout attribute.
            </summary>
            <typeparam name="TStruct">Value type to hold a reference to.</typeparam>
        </member>
        <member name="P:Reloaded.Memory.Pointers.Pointer`1.Address">
            <summary>
            Gets the pointer to the value.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.Pointer`1.MarshalElements">
            <summary>
            If this is true; elements will be marshaled as they are read in and out from memory.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.Pointer`1.Source">
            <summary>
            The source where memory will be read/written to/from.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.Pointer`1.GetValue">
            <summary>
            Gets the value at the address where the current pointer points to.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.Pointer`1.GetValue(`0@)">
            <summary>
            Gets the value at the address where the current pointer points to.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.Pointer`1.SetValue(`0)">
            <summary>
            Sets the value where the current pointer is pointing to.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.Pointer`1.SetValue(`0@)">
            <summary>
            Sets the value where the current pointer is pointing to.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.Pointer`1.#ctor(System.UInt64,System.Boolean,Reloaded.Memory.Sources.IMemory)">
            <summary>
            Constructs a new instance of <see cref="T:Reloaded.Memory.Pointers.Pointer`1"/> given the address (pointer)
            at which the value of type <typeparamref name="TStruct"/> is stored.
            </summary>
            <param name="address">The address of the pointer pointing to generic type {T}</param>
            <param name="marshalElements">If this is true; elements will be marshaled as they are read in and out from memory.</param>
            <param name="memorySource">Specifies the source from which the pointer should be read/written.</param>
        </member>
        <member name="T:Reloaded.Memory.Pointers.RefArrayPtr`1">
            <summary>
            Abstracts a native 'C' type array of unknown size in memory to a more familiar interface where
            each member of the array is returned by reference.
            </summary>
            <typeparam name="TStruct">A unmanaged native structure in the memory of the current process.</typeparam>
        </member>
        <member name="P:Reloaded.Memory.Pointers.RefArrayPtr`1.Pointer">
            <summary>
            Address of the first element of the array.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.RefArrayPtr`1.Item(System.Int32)">
            <summary>
            Returns a member of this array by reference.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefArrayPtr`1.#ctor(System.UInt64)">
            <summary>
            Creates a by reference array pointer given the address of the first element of the array.
            </summary>
            <param name="address">The address of the first element of the structure array.</param>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefArrayPtr`1.#ctor(`0*)">
            <summary>
            Creates a by reference array pointer given the address of the first element of the array.
            </summary>
            <param name="structPtr">Pointer to the address of the first element of the structure array.</param>
        </member>
        <member name="T:Reloaded.Memory.Pointers.RefFixedArrayPtr`1">
            <summary>
            Abstracts a native 'C' type array of a set size in memory to a more familiar interface where
            each member of the array is returned by reference.
            Note: This class is not safe/does not perform range checks.
            It exists to provide additional functionality like LINQ which otherwise cannot be achieved without knowing amount of elements.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.RefFixedArrayPtr`1.Pointer">
            <summary>
            Address of the first element of the array.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.RefFixedArrayPtr`1.Count">
            <summary>
            The number of elements contained in the <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/>.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.RefFixedArrayPtr`1.Item(System.Int32)">
            <summary>
            Returns a member of this array by reference.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefFixedArrayPtr`1.#ctor(System.UInt64,System.Int32)">
            <summary>
            Creates a by reference array pointer given the address of the first element of the array.
            </summary>
            <param name="address">The address of the first element of the structure array.</param>
            <param name="numberOfItems">Number of items in this array.</param>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefFixedArrayPtr`1.#ctor(`0*,System.Int32)">
            <summary>
            Creates a by reference array pointer given the address of the first element of the array.
            </summary>
            <param name="structPtr">Pointer to the address of the first element of the structure array.</param>
            <param name="numberOfItems">Number of items in this array.</param>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefFixedArrayPtr`1.Contains(`0)">
            <summary>
            Determines whether an element is in the <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/>.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefFixedArrayPtr`1.Contains(`0@)">
            <summary>
            Determines whether an element is in the <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/>.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefFixedArrayPtr`1.IndexOf(`0)">
            <summary>
            Searches for a specified item and returns the index of the item
            if present.
            </summary>
            <param name="item">The item to search for in the array.</param>
            <returns>The index of the item, if present in the array.</returns>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefFixedArrayPtr`1.IndexOf(`0@)">
            <summary>
            Searches for a specified item and returns the index of the item
            if present.
            </summary>
            <param name="item">The item to search for in the array.</param>
            <returns>The index of the item, if present in the array.</returns>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefFixedArrayPtr`1.CopyFrom(`0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies all the elements of the passed in sourceArray to the <see cref="T:Reloaded.Memory.Pointers.RefFixedArrayPtr`1"/> array.
            </summary>
            <param name="sourceArray">The array from which to copy elements from.</param>
            <param name="length">The amount of elements in the source array that should be copied.</param>
            <param name="sourceIndex">The array index in the source array copy elements from.</param>
            <param name="destinationIndex">The starting index into the <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/> to which elements should be copied to.</param>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefFixedArrayPtr`1.CopyTo(`0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies all the elements from the the <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/> to the passed in array.
            </summary>
            <param name="destinationArray">The array from which to copy elements to.</param>
            <param name="length">The amount of elements in to copy to sourceArray.</param>
            <param name="sourceIndex">The array index in the <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/> to copy elements from.</param>
            <param name="destinationIndex">The starting index into the <see cref="T:Reloaded.Memory.Pointers.FixedArrayPtr`1"/> array to which elements should be copied to.</param>
        </member>
        <member name="T:Reloaded.Memory.Pointers.RefPointer`1">
            <summary>
            Utility class which provides the ability to use a pointer of varying depth level as a by
            reference variable.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.RefPointer`1.Address">
            <summary>
            The first pointer.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Pointers.RefPointer`1.DepthLevel">
            <summary>
            Number of required dereferences to meet target address.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefPointer`1.#ctor(`0*,System.Int32)">
            <param name="address">Address of the pointer in memory.</param>
            <param name="depthLevel">Depth level of the pointer/number of required dereferences to meet target address. 1 = void*, 2 = void**, 3 - void*** etc.</param>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefPointer`1.TryDereference(`0@)">
            <summary>
            Attempts to dereference the pointer, returning the innermost pointer level as a ref type.
            If at any point along the way, the pointed to address is null, the method fails.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefPointer`1.TryDereference(`0*@)">
            <summary>
            Attempts to dereference the pointer, returning the innermost pointer as a pointer.
            If at any point along the way, the pointed to address is null, the method fails.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefPointer`1.TryDereference(System.Boolean@)">
            <summary>
            Attempts to dereference the pointer, returning the innermost pointer level as a ref type.
            If at any point along the way, the pointed to address is null, the method fails.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefPointer`1.Create(`0*)">
            <summary>
            Converts a pointer into a by reference variable.
            </summary>
            <param name="pointer">Pointer to the unmanaged structure.</param>
            <returns>A by reference variable for a given pointer.</returns>
        </member>
        <member name="M:Reloaded.Memory.Pointers.RefPointer`1.op_Implicit(Reloaded.Memory.Pointers.BlittablePointer{`0})~Reloaded.Memory.Pointers.RefPointer{`0}">
            <summary/>
        </member>
        <member name="T:Reloaded.Memory.Sources.ExternalMemory">
            <summary>
            Provides access to memory of another process on a Windows machine.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Sources.ExternalMemory._localMemory">
            <summary>
            Contains the current process' memory.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Sources.ExternalMemory._processHandle">
            <summary>
            Contains the handle of the process used to read memory
            from and write memory to external process.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Sources.ExternalMemory.#ctor(System.IntPtr)">
            <summary>
            Creates an instance of the <see cref="T:Reloaded.Memory.Sources.ExternalMemory"/> class used to read from an
            external process with a specified handle.
            </summary>
            <param name="processHandle">Handle of the process to read/write memory from.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.ExternalMemory.#ctor(System.Diagnostics.Process)">
            <summary>
            Creates an instance of the <see cref="T:Reloaded.Memory.Sources.ExternalMemory"/> class used to read from an
            external process with a specified handle.
            </summary>
            <param name="process">The individual process to read/write memory from.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.ExternalMemory.Read``1(System.IntPtr,``0@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.ExternalMemory.Read``1(System.IntPtr,``0@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.ExternalMemory.ReadRaw(System.IntPtr,System.Byte[]@,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.ExternalMemory.Write``1(System.IntPtr,``0@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.ExternalMemory.Write``1(System.IntPtr,``0@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.ExternalMemory.WriteRaw(System.IntPtr,System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.ExternalMemory.Allocate(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.ExternalMemory.Free(System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.ExternalMemory.ChangePermission(System.IntPtr,System.Int32,Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION)">
            <inheritdoc />
        </member>
        <member name="T:Reloaded.Memory.Sources.IMemory">
            <summary>
            A simple interface that provides read/write access to arbitrary memory.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Sources.IMemory.Read``1(System.IntPtr,``0@)">
            <summary>
            Reads a generic type from a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memoryAddress">The memory address to read from.</param>
            <param name="value">Local variable to receive the read in struct.</param>
            <exception cref="T:Reloaded.Memory.Exceptions.MemoryException">Failed to read memory.</exception>
        </member>
        <member name="M:Reloaded.Memory.Sources.IMemory.Read``1(System.IntPtr,``0@,System.Boolean)">
            <summary>
            Reads a generic type from a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memoryAddress">The memory address to read from.</param>
            <param name="value">Local variable to receive the read in struct.</param>
            <param name="marshal">Set this to true to enable struct marshalling.</param>
            <exception cref="T:Reloaded.Memory.Exceptions.MemoryException">Failed to read memory.</exception>
        </member>
        <member name="M:Reloaded.Memory.Sources.IMemory.ReadRaw(System.IntPtr,System.Byte[]@,System.Int32)">
            <summary>
            Reads raw data from a specified memory address.
            </summary>
            <param name="memoryAddress">The memory address to read from.</param>
            <param name="value">Local variable to receive the read in bytes.</param>
            <param name="length">The amount of bytes to read starting from the memoryAddress.</param>
            <exception cref="T:Reloaded.Memory.Exceptions.MemoryException">Failed to read memory.</exception>
        </member>
        <member name="M:Reloaded.Memory.Sources.IMemory.Write``1(System.IntPtr,``0@)">
            <summary>
            Writes a generic type to a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memoryAddress">The memory address to write to.</param>
            <param name="item">The item to write to the address.</param>
            <exception cref="T:Reloaded.Memory.Exceptions.MemoryException">Failed to write memory.</exception>
        </member>
        <member name="M:Reloaded.Memory.Sources.IMemory.Write``1(System.IntPtr,``0@,System.Boolean)">
            <summary>
            Writes a generic type to a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memoryAddress">The memory address to write to.</param>
            <param name="item">The item to write to the address.</param>
            <param name="marshal">Set this to true to enable struct marshalling.</param>
            <exception cref="T:Reloaded.Memory.Exceptions.MemoryException">Failed to write memory.</exception>
        </member>
        <member name="M:Reloaded.Memory.Sources.IMemory.WriteRaw(System.IntPtr,System.Byte[])">
            <summary>
            Writes raw data to a specified memory address.
            </summary>
            <param name="memoryAddress">The memory address to read from.</param>
            <param name="data">The bytes to write to memoryAddress.</param>
            <exception cref="T:Reloaded.Memory.Exceptions.MemoryException">Failed to write memory.</exception>
        </member>
        <member name="M:Reloaded.Memory.Sources.IMemory.Allocate(System.Int32)">
            <summary>
            Allocates fixed size of memory inside the target memory source. 
            Returns the address of newly allocated memory. 
            </summary>
            <param name="length">Amount of bytes to be allocated.</param>
            <exception cref="T:System.NotImplementedException">Thrown if a deriving class does not implement this function.</exception>
            <exception cref="T:Reloaded.Memory.Exceptions.MemoryAllocationException">Failed to allocate memory.</exception>
            <returns>Address to the newly allocated memory.</returns>
        </member>
        <member name="M:Reloaded.Memory.Sources.IMemory.Free(System.IntPtr)">
            <summary>
            Frees memory previously allocated with <see cref="M:Reloaded.Memory.Sources.IMemory.Allocate(System.Int32)"/>.
            </summary>
            <param name="address">The address of the memory to free.</param>
            <exception cref="T:System.NotImplementedException">Thrown if a deriving class does not implement this function.</exception>
            <returns>True if the operation is successful.</returns>
        </member>
        <member name="M:Reloaded.Memory.Sources.IMemory.ChangePermission(System.IntPtr,System.Int32,Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION)">
            <summary>
            Changes the page permissions for a specified combination of address and length.
            </summary>
            <param name="memoryAddress">The memory address for which to change page permissions for.</param>
            <param name="size">The region size for which to change permissions for.</param>
            <param name="newPermissions">The new permissions to set.</param>
            <exception cref="T:System.NotImplementedException">Thrown if a deriving class does not implement this function.</exception>
            <exception cref="T:Reloaded.Memory.Exceptions.MemoryPermissionException">Failed to change permissions for the following memory address and size.</exception>
            <returns>The old page permissions.</returns>
        </member>
        <member name="T:Reloaded.Memory.Sources.Memory">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Memory.Sources.Memory.CurrentProcess">
            <summary>
            Allows you to access the memory for the currently running process.
            (Alias for <see cref="P:Reloaded.Memory.Sources.Memory.Instance"/>)
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Sources.Memory.Instance">
            <summary>
            Allows you to access the memory for the currently running process.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Sources.Memory.Read``1(System.IntPtr,``0@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.Memory.Read``1(System.IntPtr,``0@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.Memory.ReadRaw(System.IntPtr,System.Byte[]@,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.Memory.Write``1(System.IntPtr,``0@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.Memory.Write``1(System.IntPtr,``0@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.Memory.WriteRaw(System.IntPtr,System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.Memory.Allocate(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.Memory.Free(System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Sources.Memory.ChangePermission(System.IntPtr,System.Int32,Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION)">
            <inheritdoc />
        </member>
        <member name="T:Reloaded.Memory.Sources.MemoryExtensions">
            <summary>
            A generic extension class that extends <see cref="T:Reloaded.Memory.Sources.IMemory"/>.
            Provides various functions such as reading arrays.
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Sources.MemoryExtensions.ReadFunction`1">
            <summary>
            See <see cref="M:Reloaded.Memory.Sources.IMemory.Read``1(System.IntPtr,``0@)"/>
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Sources.MemoryExtensions.WriteFunction`1">
            <summary>
            See <see cref="M:Reloaded.Memory.Sources.IMemory.Write``1(System.IntPtr,``0@)"/>
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.Read``1(Reloaded.Memory.Sources.IMemory,System.IntPtr,``0[]@,System.Int32,System.Boolean)">
            <summary>
            Reads a generic type array from a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="value">Local variable to receive the read in struct array.</param>
            <param name="memory"></param>
            <param name="memoryAddress">The memory address to read from.</param>
            <param name="arrayLength">The amount of array items to read.</param>
            <param name="marshal">Set this to true to enable struct marshalling.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.SafeRead``1(Reloaded.Memory.Sources.IMemory,System.IntPtr,``0@,System.Boolean)">
            <summary>
            Changes memory permissions to ensure memory can be read and reads a generic type from a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memory"></param>
            <param name="memoryAddress">The memory address to read from.</param>
            <param name="value">Local variable to receive the read in struct.</param>
            <param name="marshal">Set this to true to enable struct marshalling.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.SafeRead``1(Reloaded.Memory.Sources.IMemory,System.IntPtr,``0@)">
            <summary>
            Changes memory permissions to ensure memory can be read and reads a generic type from a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memory"></param>
            <param name="memoryAddress">The memory address to read from.</param>
            <param name="value">Local variable to receive the read in struct.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.SafeReadRaw(Reloaded.Memory.Sources.IMemory,System.IntPtr,System.Byte[]@,System.Int32)">
            <summary>
            Changes memory permissions to ensure memory can be read and reads bytes from a specified memory address.
            </summary>
            <param name="memory"></param>
            <param name="memoryAddress">The memory address to read from.</param>
            <param name="value">Local variable to receive the read in bytes.</param>
            <param name="length">The amount of bytes to read from the executable.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.SafeRead``1(Reloaded.Memory.Sources.IMemory,System.IntPtr,``0[]@,System.Int32,System.Boolean)">
            <summary>
            Changes memory permissions to ensure memory can be read and reads a generic type array from a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memory"></param>
            <param name="memoryAddress">The memory address to read from.</param>
            <param name="value">Local variable to receive the read in struct array.</param>
            <param name="arrayLength">The amount of array items to read.</param>
            <param name="marshal">Set this to true to enable struct marshalling.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.Write``1(Reloaded.Memory.Sources.IMemory,System.IntPtr,``0[],System.Boolean)">
            <summary>
            Writes a generic type array to a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memory"></param>
            <param name="memoryAddress">The memory address to write to.</param>
            <param name="items">The array of items to write to the address.</param>
            <param name="marshal">Set this to true to enable struct marshalling.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.SafeWrite``1(Reloaded.Memory.Sources.IMemory,System.IntPtr,``0@,System.Boolean)">
            <summary>
            Changes memory permissions to ensure memory can be written and writes a generic type to a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memory"></param>
            <param name="memoryAddress">The memory address to write to.</param>
            <param name="item">The items to write to the address.</param>
            <param name="marshal">Set this to true to enable struct marshalling.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.SafeWrite``1(Reloaded.Memory.Sources.IMemory,System.IntPtr,``0@)">
            <summary>
            Changes memory permissions to ensure memory can be written and writes a generic type to a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memory"></param>
            <param name="memoryAddress">The memory address to write to.</param>
            <param name="item">The items to write to the address.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.SafeWriteRaw(Reloaded.Memory.Sources.IMemory,System.IntPtr,System.Byte[])">
            <summary>
            Changes memory permissions to ensure memory can be written and writes a generic type to a specified memory address.
            </summary>
            <param name="memory"></param>
            <param name="memoryAddress">The memory address to write to.</param>
            <param name="data">The data to write to the specified address.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.SafeWrite``1(Reloaded.Memory.Sources.IMemory,System.IntPtr,``0[],System.Boolean)">
            <summary>
            Changes memory permissions to ensure memory can be written and writes a generic type array to a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memory"></param>
            <param name="memoryAddress">The memory address to write to.</param>
            <param name="items">The array of items to write to the address.</param>
            <param name="marshal">Set this to true to enable struct marshalling.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.Read``1(Reloaded.Memory.Sources.IMemory,System.IntPtr)">
            <summary>
            Reads a generic type from a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memory">Memory instance to read from.</param>
            <param name="memoryAddress">The memory address to read from.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.Read``1(Reloaded.Memory.Sources.IMemory,System.IntPtr,System.Boolean)">
            <summary>
            Reads a generic type from a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memory">Memory instance to read from.</param>
            <param name="memoryAddress">The memory address to read from.</param>
            <param name="marshal">Set true to marshal memory, else false.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.Write``1(Reloaded.Memory.Sources.IMemory,System.IntPtr,``0)">
            <summary>
            Writes a generic type to a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memory"></param>
            <param name="memoryAddress">The memory address to write to.</param>
            <param name="item">The item to write to the address.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.Write``1(Reloaded.Memory.Sources.IMemory,System.IntPtr,``0,System.Boolean)">
            <summary>
            Writes a generic type to a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memory"></param>
            <param name="memoryAddress">The memory address to write to.</param>
            <param name="item">The item to write to the address.</param>
            <param name="marshal">True to marshal the element, else false.</param>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.SafeWrite``1(Reloaded.Memory.Sources.IMemory,System.IntPtr,``0,System.Boolean)">
            <summary>
            See <see cref="M:Reloaded.Memory.Sources.MemoryExtensions.SafeWrite``1(Reloaded.Memory.Sources.IMemory,System.IntPtr,``0@,System.Boolean)"/> />
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Sources.MemoryExtensions.ChangePermission``1(Reloaded.Memory.Sources.IMemory,System.IntPtr,``0@,Reloaded.Memory.Kernel32.Kernel32.MEM_PROTECTION,System.Boolean)">
            <summary>
            Changes the page permissions for a specified combination of address and element from which to deduce size.
            </summary>
            <param name="memory"></param>
            <param name="memoryAddress">The memory address for which to change page permissions for.</param>
            <param name="baseElement">The struct element from which the region size to change permissions for will be calculated.</param>
            <param name="newPermissions">The new permissions to set.</param>
            <param name="marshalElement">Set to true to calculate the size of the struct after marshalling instead of before.</param>
            <returns>The old page permissions.</returns>
        </member>
        <member name="T:Reloaded.Memory.Streams.BufferedStreamReader">
             <summary>
             A custom <see cref="T:System.IO.BinaryReader"/> tuned for performance supporting the read of generics from another stream without unnecessary
             sanitization checks. Maintains a simple buffering layer to speed up read and write operations over slow streams.
            
             Limitation: Class cannot read structs larger than buffer size. This is not checked for!
             </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitive(System.Int16@)">
            <summary>
            Reads an unmanaged Int16 from the stream, swapping the endian of the output.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitiveInt16">
            <summary>
            Reads an unmanaged Int16 from the stream, swapping the endian of the output.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitive(System.Int16@)">
            <summary>
            Reads an unmanaged  Int16 from the stream, swapping the endian of the output without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitiveInt16">
            <summary>
            Reads an unmanaged  Int16 from the stream, swapping the endian of the output without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitive(System.UInt16@)">
            <summary>
            Reads an unmanaged UInt16 from the stream, swapping the endian of the output.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitiveUInt16">
            <summary>
            Reads an unmanaged UInt16 from the stream, swapping the endian of the output.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitive(System.UInt16@)">
            <summary>
            Reads an unmanaged  UInt16 from the stream, swapping the endian of the output without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitiveUInt16">
            <summary>
            Reads an unmanaged  UInt16 from the stream, swapping the endian of the output without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitive(System.Int32@)">
            <summary>
            Reads an unmanaged Int32 from the stream, swapping the endian of the output.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitiveInt32">
            <summary>
            Reads an unmanaged Int32 from the stream, swapping the endian of the output.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitive(System.Int32@)">
            <summary>
            Reads an unmanaged  Int32 from the stream, swapping the endian of the output without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitiveInt32">
            <summary>
            Reads an unmanaged  Int32 from the stream, swapping the endian of the output without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitive(System.UInt32@)">
            <summary>
            Reads an unmanaged UInt32 from the stream, swapping the endian of the output.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitiveUInt32">
            <summary>
            Reads an unmanaged UInt32 from the stream, swapping the endian of the output.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitive(System.UInt32@)">
            <summary>
            Reads an unmanaged  UInt32 from the stream, swapping the endian of the output without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitiveUInt32">
            <summary>
            Reads an unmanaged  UInt32 from the stream, swapping the endian of the output without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitive(System.Int64@)">
            <summary>
            Reads an unmanaged Int64 from the stream, swapping the endian of the output.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitiveInt64">
            <summary>
            Reads an unmanaged Int64 from the stream, swapping the endian of the output.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitive(System.Int64@)">
            <summary>
            Reads an unmanaged  Int64 from the stream, swapping the endian of the output without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitiveInt64">
            <summary>
            Reads an unmanaged  Int64 from the stream, swapping the endian of the output without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitive(System.UInt64@)">
            <summary>
            Reads an unmanaged UInt64 from the stream, swapping the endian of the output.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitiveUInt64">
            <summary>
            Reads an unmanaged UInt64 from the stream, swapping the endian of the output.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitive(System.UInt64@)">
            <summary>
            Reads an unmanaged  UInt64 from the stream, swapping the endian of the output without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitiveUInt64">
            <summary>
            Reads an unmanaged  UInt64 from the stream, swapping the endian of the output without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitive(System.Single@)">
            <summary>
            Reads an unmanaged Single from the stream, swapping the endian of the output.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitiveSingle">
            <summary>
            Reads an unmanaged Single from the stream, swapping the endian of the output.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitive(System.Single@)">
            <summary>
            Reads an unmanaged  Single from the stream, swapping the endian of the output without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitiveSingle">
            <summary>
            Reads an unmanaged  Single from the stream, swapping the endian of the output without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitive(System.Double@)">
            <summary>
            Reads an unmanaged Double from the stream, swapping the endian of the output.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitiveDouble">
            <summary>
            Reads an unmanaged Double from the stream, swapping the endian of the output.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitive(System.Double@)">
            <summary>
            Reads an unmanaged  Double from the stream, swapping the endian of the output without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitiveDouble">
            <summary>
            Reads an unmanaged  Double from the stream, swapping the endian of the output without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.BaseStream">
            <summary>
            Gets the stream this class was instantiated with.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.BufferBytesAvailable">
            <summary>
            Gets the remaining number of bytes that are currently buffered.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.CurrentBufferSize">
            <summary>
            Gets the total size of the current buffered data at this moment in time.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.Position">
            <summary>
            The current position of the buffer.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Constructs a <see cref="T:Reloaded.Memory.Streams.BufferedStreamReader"/>.
            </summary>
            <param name="stream">The stream to add buffering capabilities to.</param>
            <param name="bufferSize">
                The size of the buffer.
                Benchmarking suggests 65536 to be an optimal value for <see cref="T:System.IO.FileStream"/> and 512/2048 optimal for <see cref="T:System.IO.MemoryStream"/>.
                Note: With the exception of <see cref="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBytes(System.Int64,System.Int32)"/>, you may only use <see cref="M:Reloaded.Memory.Streams.BufferedStreamReader.Read``1(``0@)"/> for structs smaller than the buffer size.
            </param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.Finalize">
            <summary/>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seeks the underlying stream to a specified position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBytes(System.Int64,System.Int32)">
             <summary>
             Reads a specified amount of bytes at a specific offset from the underlying stream without
             resetting the buffers or advancing the read pointer.
            
             Note: This method is intended only for reading of large size raw data e.g. compressed file data in an archive.
                   No optimizations are performed for this action.
             </summary>
             <param name="offset">The offset of the data from the start of the stream.</param>
             <param name="count">The amount of bytes to read.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.Read``1(``0@,System.Boolean)">
            <summary>
            Reads a managed or unmanaged generic type from the stream.
            Note: For performance recommend using other overload if reading unmanaged type (i.e. marshal = false)
            </summary>
            <param name="value">The value to output.</param>
            <param name="marshal">Set to true to perform marshalling on the value being read, else false.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.Read``1(``0@)">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.Read``1(System.Boolean)">
            <summary>
            Reads a managed or unmanaged generic type from the stream.
            Note: For performance recommend using other overload if reading unmanaged type (i.e. marshal = false)
            </summary>
            <param name="marshal">Set to true to perform marshalling on the value being read, else false.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.Read``1">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.Peek``1(``0@,System.Boolean)">
            <summary>
            Reads a managed or unmanaged generic type from the stream without incrementing the position.
            Note: For performance recommend using other overload if reading unmanaged type (i.e. marshal = false)
            </summary>
            <param name="value">The value to output.</param>
            <param name="marshal">Set to true to perform marshalling on the value being read, else false.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.Peek``1(``0@)">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.Peek``1(System.Boolean)">
            <summary>
            Reads a managed or unmanaged generic type from the stream without incrementing the position.
            Note: For performance recommend using other overload if reading unmanaged type (i.e. marshal = false)
            </summary>
            <param name="marshal">Set to true to perform marshalling on the value being read, else false.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.Peek``1">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitive``1(``0@)">
            <summary>
            Reads an unmanaged primitive from the stream, swapping the endian of the output.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianStruct``1(``0@)">
            <summary>
            Reads an unmanaged struct from the stream, swapping the endian of the output.
            The structure read should implement the <see cref="T:Reloaded.Memory.IEndianReversible"/> interface.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianPrimitive``1">
            <summary>
            Reads an unmanaged primitive from the stream, swapping the endian of the output.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReadBigEndianStruct``1">
            <summary>
            Reads an unmanaged struct from the stream, swapping the endian of the output.
            The structure read should implement the <see cref="T:Reloaded.Memory.IEndianReversible"/> interface.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitive``1(``0@)">
            <summary>
            Reads an unmanaged primitive from the stream, swapping the endian of the output without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianStruct``1(``0@)">
            <summary>
            Reads an unmanaged struct from the stream, swapping the endian of the output without incrementing the position.
            The structure read should implement the <see cref="T:Reloaded.Memory.IEndianReversible"/> interface.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianPrimitive``1">
            <summary>
            Reads an unmanaged primitive from the stream, swapping the endian of the output without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.PeekBigEndianStruct``1">
            <summary>
            Reads an unmanaged struct from the stream, swapping the endian of the output without incrementing the position.
            The structure read should implement the <see cref="T:Reloaded.Memory.IEndianReversible"/> interface.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.CanRead(System.Int32)">
            <summary>
            Returns true if the <see cref="T:Reloaded.Memory.Streams.BufferedStreamReader"/> has sufficient space buffered
            to read memory of given size.
            </summary>
            <param name="size">The size of the item to check if can be read, in bytes.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReFillIfNecessary(System.Int32)">
            <summary>
            Refills the remainder of the buffer if the current buffer cannot handle the given amount of bytes.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.ReFillBuffer">
            <summary>
            Refills the remainder of the buffer.
            i.e. Preserves data to still be read (<see cref="F:Reloaded.Memory.Streams.BufferedStreamReader._bufferedBytesRemaining"/>) and reads enough data to fill rest of buffer.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.FillBuffer">
            <summary>
            Fills the buffer with new data.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.RelativeSeek(System.Int64)">
            <summary>
            Internal method that seeks the stream relatively to current position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.BufferedStreamReader.FastSeekRelativeToCurrent(System.Int64)">
            <summary>
            Tries to seek by a given offset in the existing buffer.
            Operation succeeds if offset fits in existing buffer, fails otherwise.
            </summary>
            <param name="offset">The offset relative to the current position to seek to.</param>
            <returns>Returns true if the seek was successful, else false.</returns>
        </member>
        <member name="T:Reloaded.Memory.Streams.ExtendedMemoryStream">
            <summary>
            An extended version of the <see cref="T:System.IO.MemoryStream"/> class that allows you to directly add generic structs to the stream.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.Byte)">
            <summary>
            Appends a Big Endian byte onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.Byte[])">
            <summary>
            Appends an array of Big Endian byte(s) onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.SByte)">
            <summary>
            Appends a Big Endian sbyte onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.SByte[])">
            <summary>
            Appends an array of Big Endian sbyte(s) onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.Int16)">
            <summary>
            Appends a Big Endian short onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.Int16[])">
            <summary>
            Appends an array of Big Endian short(s) onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.UInt16)">
            <summary>
            Appends a Big Endian ushort onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.UInt16[])">
            <summary>
            Appends an array of Big Endian ushort(s) onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.Int32)">
            <summary>
            Appends a Big Endian int onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.Int32[])">
            <summary>
            Appends an array of Big Endian int(s) onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.UInt32)">
            <summary>
            Appends a Big Endian uint onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.UInt32[])">
            <summary>
            Appends an array of Big Endian uint(s) onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.Int64)">
            <summary>
            Appends a Big Endian long onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.Int64[])">
            <summary>
            Appends an array of Big Endian long(s) onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.UInt64)">
            <summary>
            Appends a Big Endian ulong onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.UInt64[])">
            <summary>
            Appends an array of Big Endian ulong(s) onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.Single)">
            <summary>
            Appends a Big Endian float onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.Single[])">
            <summary>
            Appends an array of Big Endian float(s) onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.Double)">
            <summary>
            Appends a Big Endian double onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive(System.Double[])">
            <summary>
            Appends an array of Big Endian double(s) onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.#ctor">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.#ctor(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.#ctor(System.Byte[],System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.#ctor(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.AddPadding(System.Int32)">
            <summary>
            Pads the stream with 0x00 bytes until it is aligned.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.AddPadding(System.Byte,System.Int32)">
            <summary>
            Pads the stream with <see cref="!:value"/> bytes until it is aligned.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.Write``1(``0[])">
            <summary>
            Appends an unmanaged structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.Write``1(``0[],System.Boolean)">
            <summary>
            Appends an managed/marshalled structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.Write``1(``0)">
            <summary>
            Appends an unmanaged structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.Write``1(``0@)">
            <summary>
            Appends an unmanaged structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.Write``1(``0,System.Boolean)">
            <summary>
            Appends a managed/marshalled structure onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.Write``1(``0@,System.Boolean)">
            <summary>
            Appends a managed/marshalled structure onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.Write(System.Byte[])">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive``1(``0[])">
            <summary>
            Appends an unmanaged structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianStruct``1(``0[])">
            <summary>
            Appends an managed/marshalled structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianPrimitive``1(``0)">
            <summary>
            Appends an unmanaged structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.ExtendedMemoryStream.WriteBigEndianStruct``1(``0)">
            <summary>
            Appends a managed/marshalled structure onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Streams.Readers.BigEndianStreamReader">
            <summary>
            A version of <see cref="T:Reloaded.Memory.Streams.Readers.EndianStreamReader"/> that reads data in Big Endian mode.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.#ctor(Reloaded.Memory.Streams.BufferedStreamReader)">
            <summary>
            Constructs a <see cref="T:Reloaded.Memory.Streams.Readers.EndianStreamReader"/> given an existing stream reader.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Read``1(``0@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Read``1">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Peek``1(``0@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Peek``1">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.ReadStruct``1(``0@)">
            <summary>
            Reads an unmanaged struct from the stream, swapping the endian of the output.
            The structure read should implement the <see cref="T:Reloaded.Memory.IEndianReversible"/> interface.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.ReadStruct``1">
            <summary>
            Reads an unmanaged struct from the stream, swapping the endian of the output.
            The structure read should implement the <see cref="T:Reloaded.Memory.IEndianReversible"/> interface.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.PeekStruct``1(``0@)">
            <summary>
            Reads an unmanaged struct from the stream, swapping the endian of the output without incrementing the position.
            The structure read should implement the <see cref="T:Reloaded.Memory.IEndianReversible"/> interface.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.PeekStruct``1">
            <summary>
            Reads an unmanaged struct from the stream, swapping the endian of the output without incrementing the position.
            The structure read should implement the <see cref="T:Reloaded.Memory.IEndianReversible"/> interface.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Read(System.Int16@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.ReadInt16">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Peek(System.Int16@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.PeekInt16">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Read(System.UInt16@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.ReadUInt16">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Peek(System.UInt16@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.PeekUInt16">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Read(System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.ReadInt32">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Peek(System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.PeekInt32">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Read(System.UInt32@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.ReadUInt32">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Peek(System.UInt32@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.PeekUInt32">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Read(System.Int64@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.ReadInt64">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Peek(System.Int64@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.PeekInt64">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Read(System.UInt64@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.ReadUInt64">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Peek(System.UInt64@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.PeekUInt64">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Read(System.Single@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.ReadSingle">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Peek(System.Single@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.PeekSingle">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Read(System.Double@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.ReadDouble">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.Peek(System.Double@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.BigEndianStreamReader.PeekDouble">
            <inheritdoc />
        </member>
        <member name="T:Reloaded.Memory.Streams.Readers.EndianStreamReader">
            <summary>
            An abstract class that abstracts <see cref="T:Reloaded.Memory.Streams.BufferedStreamReader"/>, allowing for individual implementations for each endian.
            </summary>
            <summary>
            An abstract class that abstracts <see cref="T:Reloaded.Memory.Streams.BufferedStreamReader"/>, allowing for individual implementations for each endian.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Streams.Readers.EndianStreamReader.Reader">
            <summary>
            The underlying Stream Reader assigned to this reader.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.BaseStream">
            <summary>
            Gets the stream this class was instantiated with.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.BufferBytesAvailable">
            <summary>
            Gets the remaining number of bytes that are currently buffered.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.CurrentBufferSize">
            <summary>
            Gets the total size of the current buffered data at this moment in time.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Position">
            <summary>
            The current position of the buffer.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.#ctor(Reloaded.Memory.Streams.BufferedStreamReader)">
            <summary>
            Constructs a <see cref="T:Reloaded.Memory.Streams.Readers.EndianStreamReader"/> given an existing stream reader.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Finalize">
            <summary/>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Read``1(``0@)">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Read``1">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Peek``1(``0@)">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Peek``1">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seeks the underlying stream to a specified position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.ReadBytes(System.Int64,System.Int32)">
             <summary>
             Reads a specified amount of bytes at a specific offset from the underlying stream without
             resetting the buffers or advancing the read pointer.
            
             Note: This method is intended only for reading of large size raw data e.g. compressed file data in an archive.
                   No optimizations are performed for this action.
             </summary>
             <param name="offset">The offset of the data from the start of the stream.</param>
             <param name="count">The amount of bytes to read.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.CanRead(System.Int32)">
            <summary>
            Returns true if the <see cref="T:Reloaded.Memory.Streams.BufferedStreamReader"/> has sufficient space buffered
            to read memory of given size.
            </summary>
            <param name="size">The size of the item to check if can be read, in bytes.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Read(System.Int16@)">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.ReadInt16">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Peek(System.Int16@)">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.PeekInt16">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Read(System.UInt16@)">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.ReadUInt16">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Peek(System.UInt16@)">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.PeekUInt16">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Read(System.Int32@)">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.ReadInt32">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Peek(System.Int32@)">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.PeekInt32">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Read(System.UInt32@)">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.ReadUInt32">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Peek(System.UInt32@)">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.PeekUInt32">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Read(System.Int64@)">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.ReadInt64">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Peek(System.Int64@)">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.PeekInt64">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Read(System.UInt64@)">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.ReadUInt64">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Peek(System.UInt64@)">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.PeekUInt64">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Read(System.Single@)">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.ReadSingle">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Peek(System.Single@)">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.PeekSingle">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Read(System.Double@)">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.ReadDouble">
            <summary>
            Reads an unmanaged, generic type from the stream.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.Peek(System.Double@)">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
            <param name="value">The value to output.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.EndianStreamReader.PeekDouble">
            <summary>
            Reads an unmanaged, generic type from the stream without incrementing the position.
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader">
            <summary>
            A version of <see cref="T:Reloaded.Memory.Streams.Readers.EndianStreamReader"/> that reads data in Little Endian mode.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.#ctor(Reloaded.Memory.Streams.BufferedStreamReader)">
            <summary>
            Constructs a <see cref="T:Reloaded.Memory.Streams.Readers.EndianStreamReader"/> given an existing stream reader.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Read``1(``0@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Read``1">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Peek``1(``0@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Peek``1">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Read``1(``0@,System.Boolean)">
            <summary>
            Reads a managed or unmanaged generic type from the stream.
            Note: For performance recommend using other overload if reading unmanaged type (i.e. marshal = false)
            </summary>
            <param name="value">The value to output.</param>
            <param name="marshal">Set to true to perform marshalling on the value being read, else false.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Read``1(System.Boolean)">
            <summary>
            Reads a managed or unmanaged generic type from the stream.
            Note: For performance recommend using other overload if reading unmanaged type (i.e. marshal = false)
            </summary>
            <param name="marshal">Set to true to perform marshalling on the value being read, else false.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Peek``1(``0@,System.Boolean)">
            <summary>
            Reads a managed or unmanaged generic type from the stream without incrementing the position.
            Note: For performance recommend using other overload if reading unmanaged type (i.e. marshal = false)
            </summary>
            <param name="value">The value to output.</param>
            <param name="marshal">Set to true to perform marshalling on the value being read, else false.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Peek``1(System.Boolean)">
            <summary>
            Reads a managed or unmanaged generic type from the stream without incrementing the position.
            Note: For performance recommend using other overload if reading unmanaged type (i.e. marshal = false)
            </summary>
            <param name="marshal">Set to true to perform marshalling on the value being read, else false.</param>
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Read(System.Int16@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.ReadInt16">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Peek(System.Int16@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.PeekInt16">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Read(System.UInt16@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.ReadUInt16">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Peek(System.UInt16@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.PeekUInt16">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Read(System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.ReadInt32">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Peek(System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.PeekInt32">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Read(System.UInt32@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.ReadUInt32">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Peek(System.UInt32@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.PeekUInt32">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Read(System.Int64@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.ReadInt64">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Peek(System.Int64@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.PeekInt64">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Read(System.UInt64@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.ReadUInt64">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Peek(System.UInt64@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.PeekUInt64">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Read(System.Single@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.ReadSingle">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Peek(System.Single@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.PeekSingle">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Read(System.Double@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.ReadDouble">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.Peek(System.Double@)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Readers.LittleEndianStreamReader.PeekDouble">
            <inheritdoc />
        </member>
        <member name="T:Reloaded.Memory.Streams.StreamExtensions">
            <summary>
            Provides various extensions to streams.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.StreamExtensions.AddPadding(System.IO.Stream,System.Int32)">
            <summary>
            Pads the stream with 0x00 bytes until it is aligned.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.StreamExtensions.AddPadding(System.IO.Stream,System.Byte,System.Int32)">
            <summary>
            Pads the stream with <see cref="!:value"/> bytes until it is aligned.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.StreamExtensions.Write``1(System.IO.Stream,``0[])">
            <summary>
            Appends an unmanaged structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.StreamExtensions.Write``1(System.IO.Stream,``0[],System.Boolean)">
            <summary>
            Appends an managed/marshalled structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.StreamExtensions.Write``1(System.IO.Stream,``0)">
            <summary>
            Appends an unmanaged structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.StreamExtensions.Write``1(System.IO.Stream,``0@)">
            <summary>
            Appends an unmanaged structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.StreamExtensions.Write``1(System.IO.Stream,``0,System.Boolean)">
            <summary>
            Appends a managed/marshalled structure onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.StreamExtensions.Write``1(System.IO.Stream,``0@,System.Boolean)">
            <summary>
            Appends a managed/marshalled structure onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.StreamExtensions.Write(System.IO.Stream,System.Byte[])">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.StreamExtensions.WriteBigEndianPrimitive``1(System.IO.Stream,``0[])">
            <summary>
            Appends an unmanaged structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.StreamExtensions.WriteBigEndianStruct``1(System.IO.Stream,``0[])">
            <summary>
            Appends an managed/marshalled structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.StreamExtensions.WriteBigEndianPrimitive``1(System.IO.Stream,``0)">
            <summary>
            Appends an unmanaged structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.StreamExtensions.WriteBigEndianStruct``1(System.IO.Stream,``0)">
            <summary>
            Appends a managed/marshalled structure onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Streams.Writers.BigEndianMemoryStream">
            <summary>
            A version of <see cref="T:Reloaded.Memory.Streams.Writers.EndianMemoryStream"/> that writes data in Big Endian mode.
            </summary>
            <summary>
            A version of <see cref="T:Reloaded.Memory.Streams.Writers.EndianMemoryStream"/> that writes data in Big Endian mode.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.BigEndianMemoryStream.#ctor(Reloaded.Memory.Streams.ExtendedMemoryStream)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.BigEndianMemoryStream.Write``1(``0[])">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.BigEndianMemoryStream.Write``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.BigEndianMemoryStream.WriteStruct``1(``0[])">
            <summary>
            Appends an managed/marshalled structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.BigEndianMemoryStream.WriteStruct``1(``0)">
            <summary>
            Appends a managed/marshalled structure onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.BigEndianMemoryStream.WriteInt16(System.Int16)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.BigEndianMemoryStream.WriteUInt16(System.UInt16)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.BigEndianMemoryStream.WriteInt32(System.Int32)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.BigEndianMemoryStream.WriteUInt32(System.UInt32)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.BigEndianMemoryStream.WriteInt64(System.Int64)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.BigEndianMemoryStream.WriteUInt64(System.UInt64)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.BigEndianMemoryStream.WriteSingle(System.Single)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.BigEndianMemoryStream.WriteDouble(System.Double)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Streams.Writers.EndianMemoryStream">
            <summary>
            An abstract class that abstracts <see cref="T:Reloaded.Memory.Streams.Writers.EndianMemoryStream"/>, allowing for individual implementations for each endian.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Streams.Writers.EndianMemoryStream.Stream">
            <summary>
            The underlying Stream.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.#ctor(Reloaded.Memory.Streams.ExtendedMemoryStream)">
            <summary>
            Constructs a <see cref="T:Reloaded.Memory.Streams.Writers.EndianMemoryStream"/> given an existing stream.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.Finalize">
            <summary/>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.AddPadding(System.Int32)">
            <summary>
            Pads the stream with 0x00 bytes until it is aligned.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.AddPadding(System.Byte,System.Int32)">
            <summary>
            Pads the stream with <see cref="!:value"/> bytes until it is aligned.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.Write(System.Byte[])">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.Write``1(``0[])">
            <summary>
            Appends an unmanaged structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.Write``1(``0)">
            <summary>
            Appends an unmanaged structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.ToArray">
            <summary>
            Converts the underlying stream to an array.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.WriteInt16(System.Int16)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.WriteUInt16(System.UInt16)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.WriteInt32(System.Int32)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.WriteUInt32(System.UInt32)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.WriteInt64(System.Int64)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.WriteUInt64(System.UInt64)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.WriteSingle(System.Single)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.EndianMemoryStream.WriteDouble(System.Double)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Streams.Writers.LittleEndianMemoryStream">
            <summary>
            A version of <see cref="T:Reloaded.Memory.Streams.Writers.EndianMemoryStream"/> that writes data in Little Endian mode.
            </summary>
            <summary>
            A version of <see cref="T:Reloaded.Memory.Streams.Writers.EndianMemoryStream"/> that writes data in Big Endian mode.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.LittleEndianMemoryStream.#ctor(Reloaded.Memory.Streams.ExtendedMemoryStream)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.LittleEndianMemoryStream.Write``1(``0[])">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.LittleEndianMemoryStream.Write``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.LittleEndianMemoryStream.Write``1(``0[],System.Boolean)">
            <summary>
            Appends an managed/marshalled structure onto the <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.LittleEndianMemoryStream.Write``1(``0,System.Boolean)">
            <summary>
            Appends a managed/marshalled structure onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.LittleEndianMemoryStream.WriteInt16(System.Int16)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.LittleEndianMemoryStream.WriteUInt16(System.UInt16)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.LittleEndianMemoryStream.WriteInt32(System.Int32)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.LittleEndianMemoryStream.WriteUInt32(System.UInt32)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.LittleEndianMemoryStream.WriteInt64(System.Int64)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.LittleEndianMemoryStream.WriteUInt64(System.UInt64)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.LittleEndianMemoryStream.WriteSingle(System.Single)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Streams.Writers.LittleEndianMemoryStream.WriteDouble(System.Double)">
            <summary>
            Appends bytes onto the given <see cref="T:System.IO.MemoryStream"/> and advances the position.
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Struct">
            <summary>
            Struct is a general utility class providing functions which provides various functions for working with structures; such
            as reading/writing to/from memory of structures.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Struct.Source">
            <summary>
            Defines the source for the default memory reading and writing <see cref="M:Reloaded.Memory.Struct.ToPtr``1(System.IntPtr,``0,System.Boolean)"/> and <see cref="M:Reloaded.Memory.Struct.FromPtr``1(System.IntPtr,``0@,System.Boolean)"/> functions.
            This also affects the <see cref="T:Reloaded.Memory.StructArray"/> class.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Struct.ToPtr``1(System.IntPtr,``0,System.Boolean)">
            <summary>
            Writes an item with a specified structure or class type with explicit StructLayout attribute to a pointer/memory address.
            </summary>
            <param name="pointer">The address where to read the struct from.</param>
            <param name="item">T</param>
            <param name="marshalElement">Set to true to marshal the element.</param>
        </member>
        <member name="M:Reloaded.Memory.Struct.ToPtr``1(System.IntPtr,``0@,System.Boolean)">
            <summary>
            Writes an item with a specified structure or class type with explicit StructLayout attribute to a pointer/memory address.
            </summary>
            <param name="pointer">The address where to read the struct from.</param>
            <param name="item">The item to write to a specified pointer.</param>
            <param name="marshalElement">Set to true to marshal the element.</param>
        </member>
        <member name="M:Reloaded.Memory.Struct.FromPtr``1(System.IntPtr,``0@,System.Boolean)">
            <summary>
            Converts a pointer/memory address to a specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="pointer">The address where to read the struct from.</param>
            <param name="value">Local variable to receive the read in struct.</param>
            <param name="marshalElement">Set to true to marshal the element.</param>
        </member>
        <member name="M:Reloaded.Memory.Struct.ToPtr``1(System.IntPtr,``0@,Reloaded.Memory.Sources.MemoryExtensions.WriteFunction{``0},System.Boolean)">
            <summary>
            Writes an item with a specified structure or class type with explicit StructLayout attribute to a pointer/memory address.
            </summary>
            <param name="pointer">The address where to read the struct from.</param>
            <param name="item">The item to write to a specified pointer.</param>
            <param name="marshalElement">Set to true to marshal the element.</param>
            <param name="writeFunction">The function to use that writes data to memory given a pointer, item, type and marshal option.</param>
        </member>
        <member name="M:Reloaded.Memory.Struct.FromPtr``1(System.IntPtr,``0@,Reloaded.Memory.Sources.MemoryExtensions.ReadFunction{``0},System.Boolean)">
            <summary>
            Converts a pointer/memory address to a specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="pointer">The address where to read the struct from.</param>
            <param name="marshalElement">Set to true to marshal the element.</param>
            <param name="value">Local variable to receive the read in struct.</param>
            <param name="readFunction">A function that reads data from memory given a pointer, type and marshal option.</param>
        </member>
        <member name="M:Reloaded.Memory.Struct.FromArray``1(System.Byte[],``0@,System.Boolean,System.Int32)">
            <summary>
            Converts a byte array to a specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="data">A byte array containing data from which to extract a structure from.</param>
            <param name="value">Local variable to receive the read in struct.</param>
            <param name="marshalElement">Set to true to marshal the element.</param>
            <param name="startIndex">The index in the byte array to read the element from.</param>
        </member>
        <member name="M:Reloaded.Memory.Struct.FromArray``1(System.Byte[],``0@,System.Int32)">
            <summary>
            Converts a byte array to a specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="value">Local variable to receive the read in struct.</param>
            <param name="data">A byte array containing data from which to extract a structure from.</param>
            <param name="startIndex">The index in the byte array to read the element from.</param>
        </member>
        <member name="M:Reloaded.Memory.Struct.FromArray``1(System.Span{System.Byte},``0@)">
            <summary>
            Converts a span to a specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="value">Local variable to receive the read in struct.</param>
            <param name="data">A byte array containing data from which to extract a structure from.</param>
        </member>
        <member name="M:Reloaded.Memory.Struct.GetSize``1(System.Boolean)">
            <summary>
            Returns the size of a specific primitive or struct type.
            </summary>
            <param name="marshalElement">If set to true; will return the size of an element after marshalling.</param>
        </member>
        <member name="M:Reloaded.Memory.Struct.GetSize``1">
            <summary>
            Returns the size of a specific primitive or struct type.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Struct.GetBytes``1(``0)">
            <summary>
            Creates a byte array from specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="item">The item to convert into a byte array.</param>
        </member>
        <member name="M:Reloaded.Memory.Struct.GetBytes``1(``0,System.Span{System.Byte})">
            <summary>
            Creates a byte array from specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="item">The item to convert into a byte array.</param>
            <param name="buffer">Buffer inside which the result is to be stored.</param>
            <returns>Original span sliced to contain only the bytes of the struct.</returns>
        </member>
        <member name="M:Reloaded.Memory.Struct.GetBytes``1(``0,System.Boolean)">
            <summary>
            Creates a byte array from specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="item">The item to convert into a byte array.</param>
            <param name="marshalElement">Set to true to marshal the element.</param>
        </member>
        <member name="M:Reloaded.Memory.Struct.GetBytes``1(``0,System.Boolean,System.Span{System.Byte})">
            <summary>
            Creates a byte array from specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="item">The item to convert into a byte array.</param>
            <param name="marshalElement">Set to true to marshal the element.</param>
            <param name="buffer">Buffer inside which the result is to be stored.</param>
            <returns>Original span sliced to contain only the bytes of the struct.</returns>
        </member>
        <member name="M:Reloaded.Memory.Struct.GetBytes``1(``0@)">
            <summary>
            Creates a byte array from specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="item">The item to convert into a byte array.</param>
        </member>
        <member name="M:Reloaded.Memory.Struct.GetBytes``1(``0@,System.Span{System.Byte})">
            <summary>
            Creates a byte array from specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="item">The item to convert into a byte array.</param>
            <param name="buffer">Buffer inside which the result is to be stored.</param>
            <returns>Original span sliced to contain only the bytes of the struct.</returns>
        </member>
        <member name="M:Reloaded.Memory.Struct.GetBytes``1(``0@,System.Boolean)">
            <summary>
            Creates a byte array from specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="item">The item to convert into a byte array.</param>
            <param name="marshalElement">Set to true to marshal the element.</param>
        </member>
        <member name="M:Reloaded.Memory.Struct.GetBytes``1(``0@,System.Boolean,System.Span{System.Byte})">
            <summary>
            Creates a byte array from specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="item">The item to convert into a byte array.</param>
            <param name="marshalElement">Set to true to marshal the element.</param>
            <param name="buffer">Buffer inside which the result is to be stored.</param>
        </member>
        <member name="T:Reloaded.Memory.StructArray">
            <summary>
            Utility class for working with struct arrays.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.StructArray.FromPtr``1(System.IntPtr,``0[]@,System.Int32,System.Boolean)">
            <summary>
            Reads a generic type array from a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memoryAddress">The memory address to read from.</param>
            <param name="value">Local variable to receive the read in struct array.</param>
            <param name="arrayLength">The number of items to read from memory.</param>
            <param name="marshal">Set to true to marshal the element.</param>
        </member>
        <member name="M:Reloaded.Memory.StructArray.ToPtr``1(System.IntPtr,``0[],System.Boolean)">
            <summary>
            Writes a generic type array to a specified memory address.
            </summary>
            <typeparam name="T">An individual struct type of a class with an explicit StructLayout.LayoutKind attribute.</typeparam>
            <param name="memoryAddress">The memory address to write to.</param>
            <param name="item">The item to write to the address.</param>
            <param name="marshal">Set this to true in order to marshal the value when writing to memory.</param>
        </member>
        <member name="M:Reloaded.Memory.StructArray.FromArray``1(System.Byte[],``0[]@,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Converts a byte array to a specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="data">A byte array containing data from which to extract a structure from.</param>
            <param name="value">Local variable to receive the read in struct array.</param>
            <param name="marshalElement">Set to true to marshal the element.</param>
            <param name="length">The amount of elements to read from the byte array.</param>
            <param name="startIndex">The index in the byte array to read the element(s) from.</param>
        </member>
        <member name="M:Reloaded.Memory.StructArray.FromArray``1(System.Byte[],``0[]@,System.Int32,System.Int32)">
            <summary>
            Converts a byte array to a specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="value">Local variable to receive the read in struct array.</param>
            <param name="data">A byte array containing data from which to extract a structure from.</param>
            <param name="startIndex">The index in the byte array to read the element(s) from.</param>
            <param name="length">The amount of elements to read from the byte array.</param>
        </member>
        <member name="M:Reloaded.Memory.StructArray.FromArray``1(System.Span{System.Byte},``0[]@,System.Int32)">
            <summary>
            Converts a span to a specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="value">Local variable to receive the read in struct array.</param>
            <param name="data">A byte array containing data from which to extract a structure from.</param>
            <param name="length">The amount of elements to read from the span.</param>
        </member>
        <member name="M:Reloaded.Memory.StructArray.FromArrayBigEndianPrimitive``1(System.Byte[],``0[]@,System.Int32,System.Int32)">
            <summary>
            Converts a byte array to a specified Big Endian primitive.
            </summary>
            <param name="value">Local variable to receive the read in struct array.</param>
            <param name="data">A byte array containing data from which to extract a structure from.</param>
            <param name="startIndex">The index in the byte array to read the element(s) from.</param>
            <param name="length">The amount of elements to read from the byte array.</param>
        </member>
        <member name="M:Reloaded.Memory.StructArray.FromArrayBigEndianPrimitive``1(System.Span{System.Byte},``0[]@,System.Int32)">
            <summary>
            Converts a span to a specified Big Endian primitive.
            </summary>
            <param name="value">Local variable to receive the read in struct array.</param>
            <param name="data">A byte array containing data from which to extract a structure from.</param>
            <param name="length">The amount of elements to read from the span.</param>
        </member>
        <member name="M:Reloaded.Memory.StructArray.FromArrayBigEndianStruct``1(System.Byte[],``0[]@,System.Int32,System.Int32)">
            <summary>
            Converts a byte array to a specified Big Endian structure or class type with explicit StructLayout attribute and <see cref="T:Reloaded.Memory.IEndianReversible"/>.
            </summary>
            <param name="value">Local variable to receive the read in struct array.</param>
            <param name="data">A byte array containing data from which to extract a structure from.</param>
            <param name="startIndex">The index in the byte array to read the element(s) from.</param>
            <param name="length">The amount of elements to read from the byte array.</param>
        </member>
        <member name="M:Reloaded.Memory.StructArray.FromArrayBigEndianStruct``1(System.Span{System.Byte},``0[]@,System.Int32)">
            <summary>
            Converts a span to a specified Big Endian structure or class type with explicit StructLayout attribute and <see cref="T:Reloaded.Memory.IEndianReversible"/>..
            </summary>
            <param name="value">Local variable to receive the read in struct array.</param>
            <param name="data">A byte array containing data from which to extract a structure from.</param>
            <param name="length">The amount of elements to read from the span.</param>
        </member>
        <member name="M:Reloaded.Memory.StructArray.GetSize``1(System.Int32,System.Boolean)">
            <summary>
            Returns the size of a specific primitive or struct type.
            </summary>
            <param name="marshalElement">If set to true; will return the size of an element after marshalling.</param>
            <param name="elementCount">The number of array elements present.</param>
        </member>
        <member name="M:Reloaded.Memory.StructArray.GetSize``1(System.Int32)">
            <summary>
            Returns the size of a specific primitive or struct type.
            </summary>
            <param name="elementCount">The number of array elements present.</param>
        </member>
        <member name="M:Reloaded.Memory.StructArray.GetBytes``1(``0[],System.Boolean)">
            <summary>
            Creates a byte array from specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="items">The item to convert into a byte array.</param>
            <param name="marshalElements">Set to true to marshal the item(s).</param>
        </member>
        <member name="M:Reloaded.Memory.StructArray.GetBytes``1(``0[],System.Boolean,System.Span{System.Byte})">
            <summary>
            Creates a byte array from specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="items">The item to convert into a byte array.</param>
            <param name="marshalElements">Set to true to marshal the item(s).</param>
            <param name="buffer">The buffer to which write the bytes to.</param>
            <returns>The passed in buffer sliced to include only the bytes obtained.</returns>
        </member>
        <member name="M:Reloaded.Memory.StructArray.GetBytes``1(``0[])">
            <summary>
            Creates a byte array from specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="items">The item to convert into a byte array.</param>
        </member>
        <member name="M:Reloaded.Memory.StructArray.GetBytes``1(``0[],System.Span{System.Byte})">
            <summary>
            Creates a byte array from specified structure or class type with explicit StructLayout attribute.
            </summary>
            <param name="items">The item to convert into a byte array.</param>
            <param name="buffer">The buffer to which write the bytes to.</param>
            <returns>The passed in buffer sliced to include only the bytes obtained.</returns>
        </member>
        <member name="T:Reloaded.Memory.Utilities.Blittable">
            <summary>
            A group of useful utility methods for determining if a type is blittable.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Utilities.Blittable.IsBlittable``1">
            <summary>
            Returns true if a type is blittable, else false.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Utilities.Blittable.IsBlittable(System.Type)">
            <summary>
            Checks if a type is blittable.
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Utilities.CircularBuffer">
            <summary>
            The <see cref="T:Reloaded.Memory.Utilities.CircularBuffer"/> is a writeable buffer useful for temporary storage of data.
            It's a buffer whereby once you reach the end of the buffer, it loops back over to the beginning of the stream automatically.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Utilities.CircularBuffer.Source">
            <summary>
            Access to memory source where the <see cref="T:Reloaded.Memory.Utilities.CircularBuffer"/> reads from/writes to.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Utilities.CircularBuffer.Offset">
            <summary>
            Current offset of next item within the <see cref="T:Reloaded.Memory.Utilities.CircularBuffer"/>.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Utilities.CircularBuffer.Address">
            <summary>
            The address of the <see cref="T:Reloaded.Memory.Utilities.CircularBuffer"/>.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Utilities.CircularBuffer.Size">
            <summary>
            Size of the <see cref="T:Reloaded.Memory.Utilities.CircularBuffer"/>.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Utilities.CircularBuffer.WritePointer">
            <summary>
            Returns the address of where the next element will be written onto the buffer.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Utilities.CircularBuffer.Remaining">
            <summary> Remaining space until the Circular buffer next loops. </summary>
        </member>
        <member name="M:Reloaded.Memory.Utilities.CircularBuffer.#ctor(System.Int32,Reloaded.Memory.Sources.IMemory)">
            <summary>
            Creates a <see cref="T:Reloaded.Memory.Utilities.CircularBuffer"/> within the target memory source.
            </summary>
            <param name="size">The size of the buffer in bytes.</param>
            <param name="source">The source of the buffer where to read/write elements to/from.</param>
        </member>
        <member name="M:Reloaded.Memory.Utilities.CircularBuffer.Finalize">
            <summary>
            Destroys the current class instance.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Utilities.CircularBuffer.Add(System.Byte[])">
            <summary>
            Adds a new item onto the circular buffer.
            </summary>
            <param name="bytesToWrite">The bytes to add onto the buffer.</param>
            <returns>Pointer to the recently added item to the buffer, or IntPtr.Zero if the item cannot fit.</returns>
        </member>
        <member name="M:Reloaded.Memory.Utilities.CircularBuffer.Add``1(``0@,System.Boolean)">
            <summary>
            Adds a new item onto the circular buffer.
            </summary>
            <param name="item">The item to add onto the buffer.</param>
            <param name="marshalElement">The element to be marshalled.</param>
            <returns>Pointer to the recently added item to the buffer.</returns>
        </member>
        <member name="M:Reloaded.Memory.Utilities.CircularBuffer.CanItemFit(System.Int32)">
            <summary>
            Returns an enumerable describing if an item can fit into the buffer.
            </summary>
            <param name="objectSize">The size of the object to be appended to the buffer.</param>
        </member>
        <member name="M:Reloaded.Memory.Utilities.CircularBuffer.CanItemFit``1(``0@,System.Boolean)">
            <summary>
            Returns an enumerable describing if an item can fit into the buffer.
            </summary>
            <param name="item">The item to check if it can fit into the buffer.</param>
            <param name="marshalElement">True if the item is to be marshalled, else false.</param>
        </member>
        <member name="T:Reloaded.Memory.Utilities.CircularBuffer.ItemFit">
            <summary/>
        </member>
        <member name="F:Reloaded.Memory.Utilities.CircularBuffer.ItemFit.No">
            <summary> The item is too large to fit into the buffer. </summary>
        </member>
        <member name="F:Reloaded.Memory.Utilities.CircularBuffer.ItemFit.Yes">
            <summary> The item can fit into the buffer. </summary>
        </member>
        <member name="F:Reloaded.Memory.Utilities.CircularBuffer.ItemFit.StartOfBuffer">
            <summary> The item can fit into the buffer, but not in the remaining space (will be placed at start of buffer).</summary>
        </member>
        <member name="M:Reloaded.Memory.Utilities.CircularBuffer.Dispose">
            <summary/>
        </member>
    </members>
</doc>
